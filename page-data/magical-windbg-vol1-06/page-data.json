{"componentChunkName":"component---src-templates-post-template-js","path":"/magical-windbg-vol1-06","result":{"data":{"markdownRemark":{"id":"0c472af8-f73a-5489-8fa1-918ac04cce12","html":"<p>4 章と 5 章では、アプリケーションクラッシュダンプやフルメモリダンプから、プロセスやシステムがクラッシュした原因を調査しました。</p>\n<p>ここまでの章で確認した通り、ダンプファイルの作成時には通常、クラッシュの原因となった例外の情報が含まれます。</p>\n<p>そのため、<code class=\"language-text\">!analyze -v</code> などのコマンドによってダンプ生成時の例外情報を参照することで、クラッシュが発生した直接の原因(例外)を特定することは比較的容易です。</p>\n<p>しかし、クラッシュ以外の問題の原因をダンプファイルから調査する場合には、ダンプファイル作成時に収集される例外発生時の情報が調査の役に立たなくなるため、少々解析の難易度が上がります。</p>\n<p>6 章と 7 章では、クラッシュ以外の問題の発生をダンプファイルから調査する例として、ユーザモードアプリケーションのメモリリーク事象を使用します。</p>\n<p>本章では、メモリリーク事象を引き起こしているアプリケーションのプロセスダンプの解析を行います。</p>\n<!-- omit in toc -->\n<h2 id=\"もくじ\" style=\"position:relative;\"><a href=\"#%E3%82%82%E3%81%8F%E3%81%98\" aria-label=\"もくじ permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>もくじ</h2>\n<ul>\n<li><a href=\"#%E3%83%A1%E3%83%A2%E3%83%AA%E3%83%AA%E3%83%BC%E3%82%AF%E4%BA%8B%E8%B1%A1%E3%81%AE%E5%86%8D%E7%8F%BE\">メモリリーク事象の再現</a></li>\n<li><a href=\"#%E3%83%97%E3%83%AD%E3%82%BB%E3%82%B9%E3%83%80%E3%83%B3%E3%83%97%E3%82%92%E5%8F%96%E5%BE%97%E3%81%99%E3%82%8B\">プロセスダンプを取得する</a></li>\n<li><a href=\"#%E3%83%97%E3%83%AD%E3%82%BB%E3%82%B9%E3%83%80%E3%83%B3%E3%83%97%E3%81%AE%E4%BE%8B%E5%A4%96%E3%82%B3%E3%83%BC%E3%83%89%E3%82%92%E8%AA%BF%E3%81%B9%E3%82%8B\">プロセスダンプの例外コードを調べる</a></li>\n<li><a href=\"#%E3%83%80%E3%83%B3%E3%83%97%E3%83%95%E3%82%A1%E3%82%A4%E3%83%AB%E3%81%8B%E3%82%89%E3%83%A1%E3%83%A2%E3%83%AA%E3%83%AA%E3%83%BC%E3%82%AF%E4%BA%8B%E8%B1%A1%E3%82%92%E8%AA%BF%E6%9F%BB%E3%81%99%E3%82%8B%E5%89%8D%E3%81%AE%E6%BA%96%E5%82%99\">ダンプファイルからメモリリーク事象を調査する前の準備</a></li>\n<li><a href=\"#%E3%83%97%E3%83%AD%E3%82%BB%E3%82%B9%E3%83%80%E3%83%B3%E3%83%97%E3%81%8B%E3%82%89-heap-%E9%A0%98%E5%9F%9F%E3%82%92%E8%AA%BF%E6%9F%BB%E3%81%99%E3%82%8B\">プロセスダンプから Heap 領域を調査する</a></li>\n<li><a href=\"#%E3%83%A1%E3%83%A2%E3%83%AA%E3%83%AA%E3%83%BC%E3%82%AF%E3%81%AE%E5%8E%9F%E5%9B%A0%E7%AE%87%E6%89%80%E3%82%92%E7%89%B9%E5%AE%9A%E3%81%99%E3%82%8B\">メモリリークの原因箇所を特定する</a></li>\n<li><a href=\"#%E5%90%84%E3%82%B9%E3%83%AC%E3%83%83%E3%83%89%E3%81%8C%E5%AE%9F%E8%A1%8C%E3%81%97%E3%81%A6%E3%81%84%E3%82%8B%E5%87%A6%E7%90%86%E3%82%92%E8%A7%A3%E6%9E%90%E3%81%99%E3%82%8B\">各スレッドが実行している処理を解析する</a></li>\n<li><a href=\"#6-%E7%AB%A0%E3%81%AE%E3%81%BE%E3%81%A8%E3%82%81\">6 章のまとめ</a></li>\n<li><a href=\"#%E5%90%84%E7%AB%A0%E3%81%B8%E3%81%AE%E3%83%AA%E3%83%B3%E3%82%AF\">各章へのリンク</a></li>\n</ul>\n<h2 id=\"メモリリーク事象の再現\" style=\"position:relative;\"><a href=\"#%E3%83%A1%E3%83%A2%E3%83%AA%E3%83%AA%E3%83%BC%E3%82%AF%E4%BA%8B%E8%B1%A1%E3%81%AE%E5%86%8D%E7%8F%BE\" aria-label=\"メモリリーク事象の再現 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>メモリリーク事象の再現</h2>\n<p>まずは、解析対象のプロセスダンプを取得するためにメモリリーク事象を発生させましょう。</p>\n<p>前章までと同じく、D4C.exe を使用して問題を再現します。</p>\n<p>D4C.exe を起動し、最初のメニューで 2 を入力してメモリリーク事象の再現を開始します。</p>\n<p><span\n      class=\"gatsby-resp-image-wrapper\"\n      style=\"position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 500px; \"\n    >\n      <a\n    class=\"gatsby-resp-image-link\"\n    href=\"/static/c9686e0bd856e304ccbd48f263c244c5/0b533/mem-leak-001.png\"\n    style=\"display: block\"\n    target=\"_blank\"\n    rel=\"noopener\"\n  >\n    <span\n    class=\"gatsby-resp-image-background-image\"\n    style=\"padding-bottom: 76.66666666666666%; position: relative; bottom: 0; left: 0; background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAPCAYAAADkmO9VAAAACXBIWXMAAA7EAAAOxAGVKw4bAAACNklEQVQ4y42TS2/TQBSFDUpC4lect+147PEj8atpRSR+E2wRC1YsCGxb/gYgiEARXVAoISqs+UeHO5OkhLaBLo6uc618PufeGWX++Rvmi094+2Eh9Wb+Ea9J7xenOPt+gS+rH7Jun7+ufu6I3i0vcHq2xPlyhXfnv6D0XQ+9ThtqowFdU2HquqxN04CmUk+lnqFLqY06atXKddVqqNxR8OjpSyjBKEORZzg4mKAoSlKBsiwxnU7lc5pmyKn2+31YlgXDMG6QCa1ew+Pnr6DYjMNzXQQBx3A4BPMZHMdBFEXyt+d5Us1mEyq51UWCazKg3quugXFWggcBAQMkSUKgGGEYYjweYzAYoNvtoiHGsfmzpml7gJU1MDu8j/EoQZbnmEwmyKmKmL7vy5hb6M2gK8DZCZQwzRGRI89jEuJSXOGW0wjsgY1WqwXTNG8BFJFPxFJSxDQvRkAxR2/oSbD4iIi+G1lA90feAPkG6DMfnHO5AOFQ9MQH2u32JWS/y12HycYhYxIkNivA256IfOulzGgpUVZQPH4JFA5deYzIZRzDtm3pUpy3fzsk4AsCjsoJQr4GCajj2LIKpxa5E+dPQP8PrK637FPkhJyIRYglSKcUWZ5J6nd7PdTr9T+Rr0j2je0Mj2mG8QhJGMAnh5ygzHVkTaIQAfPQtprQ6A7r8l7vEd19tXoXT2YE5EcPEJdHcJMMLC3gxCnYuEBYHMIb5bBcH2rHhtZ1SPbf6mxE71SzhYfPjvEbvIqsR9VDrFUAAAAASUVORK5CYII='); background-size: cover; display: block;\"\n  ></span>\n  <picture>\n          <source\n              srcset=\"/static/c9686e0bd856e304ccbd48f263c244c5/8ac56/mem-leak-001.webp 240w,\n/static/c9686e0bd856e304ccbd48f263c244c5/d3be9/mem-leak-001.webp 480w,\n/static/c9686e0bd856e304ccbd48f263c244c5/b0a15/mem-leak-001.webp 500w\"\n              sizes=\"(max-width: 500px) 100vw, 500px\"\n              type=\"image/webp\"\n            />\n          <source\n            srcset=\"/static/c9686e0bd856e304ccbd48f263c244c5/8ff5a/mem-leak-001.png 240w,\n/static/c9686e0bd856e304ccbd48f263c244c5/e85cb/mem-leak-001.png 480w,\n/static/c9686e0bd856e304ccbd48f263c244c5/0b533/mem-leak-001.png 500w\"\n            sizes=\"(max-width: 500px) 100vw, 500px\"\n            type=\"image/png\"\n          />\n          <img\n            class=\"gatsby-resp-image-image\"\n            src=\"/static/c9686e0bd856e304ccbd48f263c244c5/0b533/mem-leak-001.png\"\n            alt=\"D4C.exe でユーザモードメモリリーク事象の再現\"\n            title=\"D4C.exe でユーザモードメモリリーク事象の再現\"\n            loading=\"lazy\"\n            style=\"width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;\"\n          />\n        </picture>\n  </a>\n    </span></p>\n<p>実行が始まると、D4C.exe のプロセスのプライベートなメモリが次々と割り当てられ、プロセスの仮想メモリ<sup id=\"fnref-1\"><a href=\"#fn-1\" class=\"footnote-ref\">1</a></sup>領域がリークしていきます。</p>\n<p>アプリケーションの仮想メモリ領域が肥大化すると、最終的には RDP 接続がブラックアウトして切断されたり、システム操作やデスクトップ GUI の描画が遅延するなど深刻な問題が発生する場合があります。</p>\n<p>ちなみに、D4C.exe の実行後にプロセスの仮想メモリがリークしていく様子は、Sysinternals に含まれる Process Explorer を使用することで確認できます。</p>\n<p>また、システム全体で割り当てられた仮想メモリが増大している様子は、タスクマネージャを使用することで確認できます。</p>\n<p>以下は、実際にユーザモードのメモリリーク事象を再現しているタイミングで Process Explorer とタスクマネージャを起動した際の画面キャプチャです。</p>\n<p><span\n      class=\"gatsby-resp-image-wrapper\"\n      style=\"position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 500px; \"\n    >\n      <a\n    class=\"gatsby-resp-image-link\"\n    href=\"/static/5c859791feb135bdd9bcccddc489040f/0b533/mem-leak-002.png\"\n    style=\"display: block\"\n    target=\"_blank\"\n    rel=\"noopener\"\n  >\n    <span\n    class=\"gatsby-resp-image-background-image\"\n    style=\"padding-bottom: 64.99999999999999%; position: relative; bottom: 0; left: 0; background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAANCAYAAACpUE5eAAAACXBIWXMAAA7EAAAOxAGVKw4bAAACiUlEQVQ4y4VTy24TQRDcr+TMryAhceFKOIA4wIUDUpQQBREDISKOBZZjO4Y4ceIYE3ufzs7s7sw+Z130jJPwOjCrUvc+premusv64YdgEUPAQvCIY7FYgDGGJIkJEUTMIYRAXuQoCGVZGOQ53Zclqqqi58UtrIvzKdxpAO4kcGcezsZ9TIZtXPb3MT7+hsloivk8wdyOcDFxKDKEYUI/DRHHCdI0pR8nlMcGVuPjHtaevcD6dgO7zQM49gy+58Cdz2kTMZQFbZAGWaaZaUYVlFKGnUZJTDWiKIL1+qCFB+sbWPvUxJv+AIlIwTkDC68gRYLA94wUUgos6Votypa/ga66rlcFm1/G+PruFE4nxGzE4CUK312OQChkJUgGB0VaAQqoCmWgivoav+5lnMJ3A1ib7QHub+/hUe8MW8dTeG6G1sjH/pjBZlSlrKlgaVBmdDwqbuJfucprxKSttXE4xL2tXTzujNCYzKDqFIyOrEibulKIrxJInt5CMLkC/zPqd2HAYLUPR+juHuHqnPSibpd5RI2Zww8oJ/F5EN0WK8SKSZUpg5tcM1UZMWTU5eftDu5sbuJuq4WnxwNAhvCpEUJKKl7SMWgeeWI0EpGkoxdQJENF3c5ljlrnpGNdLek7AWu708PDnQaedHvYOT1BQcPsuK6ZLT2oNrH1PA8BDXxArMOQDMA5dZQbA5ieL1fdl0TC2u8N8PL9e3wYnqB/OUNOfWCMm4HVs2bbtjm+bTu0ITUbjUuunfFPweZhF6923mLvqI/B5EK/xc1S9dLMZEw21M7439IkrO7nHqaNA1TdMRbDMS7JKZ4zR0gsbT+mKJDEGfm5oKLacoLyjFyTmgJZlpmoWWsJfgIfANIgq66FSwAAAABJRU5ErkJggg=='); background-size: cover; display: block;\"\n  ></span>\n  <picture>\n          <source\n              srcset=\"/static/5c859791feb135bdd9bcccddc489040f/8ac56/mem-leak-002.webp 240w,\n/static/5c859791feb135bdd9bcccddc489040f/d3be9/mem-leak-002.webp 480w,\n/static/5c859791feb135bdd9bcccddc489040f/b0a15/mem-leak-002.webp 500w\"\n              sizes=\"(max-width: 500px) 100vw, 500px\"\n              type=\"image/webp\"\n            />\n          <source\n            srcset=\"/static/5c859791feb135bdd9bcccddc489040f/8ff5a/mem-leak-002.png 240w,\n/static/5c859791feb135bdd9bcccddc489040f/e85cb/mem-leak-002.png 480w,\n/static/5c859791feb135bdd9bcccddc489040f/0b533/mem-leak-002.png 500w\"\n            sizes=\"(max-width: 500px) 100vw, 500px\"\n            type=\"image/png\"\n          />\n          <img\n            class=\"gatsby-resp-image-image\"\n            src=\"/static/5c859791feb135bdd9bcccddc489040f/0b533/mem-leak-002.png\"\n            alt=\"ユーザモードメモリリーク事象発生時のメモリリソース\"\n            title=\"ユーザモードメモリリーク事象発生時のメモリリソース\"\n            loading=\"lazy\"\n            style=\"width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;\"\n          />\n        </picture>\n  </a>\n    </span></p>\n<p>Process Explorer では、D4C.exe 行の [Private Bytes] 列のサイズが時間とともに増大していく様子を確認できます。</p>\n<p>また、タスクマネージャの [パフォーマンス] タブでも、コミット済みの仮想メモリのサイズが増大していることを確認できます。</p>\n<p>なお、プロセスのメモリ消費量については、Process Explorer やタスクマネージャ以外にも、リソースモニターや VMMap、Process Hacker など様々なツールで調べることが可能です。</p>\n<p>そのため、メモリリークが疑われる状況の場合には、環境や好みに合わせて好きなツールを使用すると良いでしょう。</p>\n<h2 id=\"プロセスダンプを取得する\" style=\"position:relative;\"><a href=\"#%E3%83%97%E3%83%AD%E3%82%BB%E3%82%B9%E3%83%80%E3%83%B3%E3%83%97%E3%82%92%E5%8F%96%E5%BE%97%E3%81%99%E3%82%8B\" aria-label=\"プロセスダンプを取得する permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>プロセスダンプを取得する</h2>\n<p>D4C.exe を使用してアプリケーションのメモリリーク事象を再現できたので、次は解析用のプロセスダンプの取得を行います。</p>\n<p>メモリリークのようなアプリケーションクラッシュを伴わない問題の場合は、4 章のように自動的にアプリケーションクラッシュダンプが生成されません。</p>\n<p>そのため、問題が発生しているタイミングで任意のツールを使用してプロセスのダンプファイルを取得する必要があります。</p>\n<p>プロセスのダンプファイルを取得できるツールはいくつもありますが、本書では Sysinternals に含まれる Process Explorer と Procdump を使用します。</p>\n<p>まずは Process Explorer を使用してダンプファイルを取得します。</p>\n<p>先ほどプロセスのメモリ使用量を調査した場合と同じく、管理者権限で Process Explorer を起動します。</p>\n<p>続いて、プロセスの一覧から D4C.exe の行を右クリックし、[Create Dump]>[Create Full Dump…] をクリックします。</p>\n<p><span\n      class=\"gatsby-resp-image-wrapper\"\n      style=\"position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 500px; \"\n    >\n      <a\n    class=\"gatsby-resp-image-link\"\n    href=\"/static/6af4e90dbf17abd55228873bcbbee4f8/0b533/mem-leak-003.png\"\n    style=\"display: block\"\n    target=\"_blank\"\n    rel=\"noopener\"\n  >\n    <span\n    class=\"gatsby-resp-image-background-image\"\n    style=\"padding-bottom: 78.33333333333333%; position: relative; bottom: 0; left: 0; background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAQCAYAAAAWGF8bAAAACXBIWXMAAA7DAAAOwwHHb6hkAAAD/UlEQVQ4yy2U2W8bVRjF56+CV8TygATPVCDgAZBoHygSQiAeKgRCFBUhUaV0SdMtCU0cx/USu/FWOe44dmI7tuMkbprEjT3jbWbsiXcnsf3jJuVKR7rS1T3f951z9EmmYaAoRWrVGmbdRKvVKKkKmm6gaRqVcpnyGUpl6nUDXdcxtBqG+FetVDBNk3qjId4aGPU60v6hwstilapmkNnZpGQc8ULRaFRUjswmiloW5A1BWqNhtuifDAVGdAdDuv0Tup0OneYRnVaTwfEJUqmkcnbGJz3MRkFcTjkdDhl3THrdJkX1kKa+i6ZsUj5M0zgQRVN+aikHR2qGZjlPczdBcz/NuN9EerapcGutxfVom2uRHr+vmPwRNnmcaTGzrmDZUPh3Nc18OMaCvMacL879hQBX73n4zbHD37LBT84C39ny/OzXkNzLMtd+uc2fV+8zObGI9ZEPy0Mvuhi9XNUoKmU6gxFiynOIKwdqjWlvnHmbzM2/ppmZWmLuwTIzky6kO8FF3rx5g7fv3eE9+wLvP3XygYDRfa1NsVCgIcRmPGIscHbqehUlFmTieYA3/rnOu1O3eOfBJG/dnkAKxBNYwjLezS0yRp20cDet6UL4U+FcXbhbOndyPIbR6DVhTbibW5PZPtjHsZ4QUkRYjMbwbKSQ5FAY2727+G1Wwk47EbeL5LMALfUVR4aIiCjSarcF4ficbDAYoIqud+NRNuUQ1qm7LFvmCT6xCiwiOTwyjpsPcN6dRba4iFrdJJeC9MwGLTHyWZdnHfb7/XOyZquFWiyQWAnwQo7hf2TFNfUY9/05gjOCcDJUwu0p4VwusRIdEE2MiSWhf4wIsUZVBH00GjMU4w6H/2soQp2WfexkDZ766jiWCjjdRdzeCtKsP4l/NkTIFmdrpch2WCUnq4wGfdqmhlEtw+ngLKkCw3PCVl0XhAH2NvYJOlJ4FqK4LasEFsJIc6kMnwd8XJLDXMxm+DKb5uJWhm+9PS4vww8B+N4PXy/BVy742DrmYfJYFNMp5vMc7r7gILeDXiziTK0jra6u4Zm34Lc7SEcivMpmUXd22K30iefbxA+OiO2ZhHMG8l6TnDbClTvhM9uIb+w9flg64Uf3gEsOuGGJI02HcswuJZh+muDJyh7BlEYoW0dvdum1TLqmwXGvKSQQTh93zkfWhfO+QITH8gFXnmzzq32bKwITS0mkiUiSD21OPnJ7ubAc5IuVKJdze+w2WmLzaBQKKpWqzuvQQLs7EIuixN5zH7O5LBf8AT71ePjE7eFCIIi0Hs+zYU+SdCXZ8ubQknUaKbFdCm0KiopSKorc7VMtF9Brglw5pJTf52U6Rin9iowrQ9qTJeFMErOn+A/I0FB+UsG8mgAAAABJRU5ErkJggg=='); background-size: cover; display: block;\"\n  ></span>\n  <picture>\n          <source\n              srcset=\"/static/6af4e90dbf17abd55228873bcbbee4f8/8ac56/mem-leak-003.webp 240w,\n/static/6af4e90dbf17abd55228873bcbbee4f8/d3be9/mem-leak-003.webp 480w,\n/static/6af4e90dbf17abd55228873bcbbee4f8/b0a15/mem-leak-003.webp 500w\"\n              sizes=\"(max-width: 500px) 100vw, 500px\"\n              type=\"image/webp\"\n            />\n          <source\n            srcset=\"/static/6af4e90dbf17abd55228873bcbbee4f8/8ff5a/mem-leak-003.png 240w,\n/static/6af4e90dbf17abd55228873bcbbee4f8/e85cb/mem-leak-003.png 480w,\n/static/6af4e90dbf17abd55228873bcbbee4f8/0b533/mem-leak-003.png 500w\"\n            sizes=\"(max-width: 500px) 100vw, 500px\"\n            type=\"image/png\"\n          />\n          <img\n            class=\"gatsby-resp-image-image\"\n            src=\"/static/6af4e90dbf17abd55228873bcbbee4f8/0b533/mem-leak-003.png\"\n            alt=\"Process Explorer を使用してプロセスダンプを取得\"\n            title=\"Process Explorer を使用してプロセスダンプを取得\"\n            loading=\"lazy\"\n            style=\"width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;\"\n          />\n        </picture>\n  </a>\n    </span></p>\n<p>するとファイルエクスプローラのウインドウが起動するので、任意のフォルダにダンプファイルを保存してください。</p>\n<p>プロセスのフルダンプ取得に成功した場合、指定のフォルダ内に Process Explorer の [Private Bytes] 列で確認したプロセスのメモリサイズとほぼ同等のサイズのダンプファイルが生成されます。</p>\n<p>Process Explorer でダンプファイルを取得した場合、D4C.exe のアプリケーションは終了されないため、[Ctrl+C] キーを使用して手動でアプリケーションを終了します。</p>\n<p>これで解析用のプロセスダンプを取得できましたが、同等のダンプファイルは Procdump を使用することでも取得できます。</p>\n<p>Procdump の使用方法は非常に簡単です。</p>\n<p>D4C.exe のプロセスダンプを取得する場合、管理者権限で起動したコマンドプロンプトで以下のコマンドを実行します。</p>\n<div class=\"gatsby-highlight\" data-language=\"powershell\"><pre class=\"language-powershell\"><code class=\"language-powershell\">procdump<span class=\"token punctuation\">.</span>exe <span class=\"token operator\">-</span>ma <span class=\"token operator\">-</span>w D4C<span class=\"token punctuation\">.</span>exe</code></pre></div>\n<p>上記のコマンドを実行すると、カレントフォルダにプロセスダンプが生成されます。</p>\n<p><code class=\"language-text\">-ma</code> オプションでは、取得するダンプの種類をフルダンプに指定しています。</p>\n<p>また、<code class=\"language-text\">-w</code> オプションでは、ダンプファイルを取得するプロセス名を指定します。</p>\n<p>本書では使用しませんが、Procdump を使用してアプリケーションのプロセスダンプを取得する場合は、アプリケーションハングの発生や、CPU やメモリサイズのしきい値など、プロセスダンプの取得条件を細かく定義できます。</p>\n<p>そのため、問題の再現条件がタイミングが不明な場合には、Procdump を使用して任意の条件でプロセスダンプを取得することで、問題の調査に必要なダンプファイルをスムーズに取得できます。</p>\n<p>Procdump のオプション一覧については公開情報の記載を参照してください。</p>\n<br>\n<p>ProcDump:</p>\n<p><a href=\"https://learn.microsoft.com/ja-jp/sysinternals/downloads/procdump\" target=\"_blank\" rel=\"nofollow noopener noreferrer\">https://learn.microsoft.com/ja-jp/sysinternals/downloads/procdump</a></p>\n<br>\n<h2 id=\"プロセスダンプの例外コードを調べる\" style=\"position:relative;\"><a href=\"#%E3%83%97%E3%83%AD%E3%82%BB%E3%82%B9%E3%83%80%E3%83%B3%E3%83%97%E3%81%AE%E4%BE%8B%E5%A4%96%E3%82%B3%E3%83%BC%E3%83%89%E3%82%92%E8%AA%BF%E3%81%B9%E3%82%8B\" aria-label=\"プロセスダンプの例外コードを調べる permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>プロセスダンプの例外コードを調べる</h2>\n<p>解析用のプロセスダンプを取得できたので、メモリリーク事象の調査を始めていきます。</p>\n<p>4 章と同じく WinDbg にプロセスダンプをロードし、例外コードを調べるところから解析を始めていきます。</p>\n<p>使用するダンプファイルは Process Explorer と Procdump どちらで取得したものでも構いません。</p>\n<p>以下の通り、どちらの方法で取得したプロセスダンプも <code class=\"language-text\">.exr -1</code> コマンドで取得できる例外情報は同じです。</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\"># Process Explorer で取得したプロセスダンプの例外コード\n0:000> .exr -1\nExceptionAddress: 0000000000000000\n   ExceptionCode: 80000003 (Break instruction exception)\n  ExceptionFlags: 00000000\nNumberParameters: 0\n\n# Procdump で取得したプロセスダンプの例外コード\n0:000> .exr -1\nExceptionAddress: 0000000000000000\n   ExceptionCode: 80000003 (Break instruction exception)\n  ExceptionFlags: 00000000\nNumberParameters: 0</code></pre></div>\n<p>ここで、取得したプロセスダンプに記録されている例外コードが 0x80000003 であることがわかります。</p>\n<p>公式ドキュメント<sup id=\"fnref-2\"><a href=\"#fn-2\" class=\"footnote-ref\">2</a></sup>の記載を参照すると、この例外コードはブレークポイントの検出に関するものであることがわかります。</p>\n<p>また、<code class=\"language-text\">.exr -1</code> コマンドの出力結果にも <code class=\"language-text\">Break instruction exception</code> と記載されている通り、この例外はブレークポイントに関連していることがわかります。</p>\n<p>しかし、当然ですが D4C.exe にはブレークポイントはハードコードされていません。</p>\n<p>つまり、この例外はダンプファイルを生成するために Process Explorer や Procdump が強制的に引き起こしたものであると判断できます。</p>\n<p>このように、クラッシュを伴わない問題の調査をするためにダンプファイルを生成する場合、ツールが意図的に例外を発生させます。</p>\n<p>そのため、今回のメモリリーク事象のような、クラッシュを伴わない問題をダンプファイルを解析する場合には、 <code class=\"language-text\">.exr -1</code> や <code class=\"language-text\">!analyze -v</code> で取得できる例外情報は役に立たなくなることに注意が必要です。</p>\n<h2 id=\"ダンプファイルからメモリリーク事象を調査する前の準備\" style=\"position:relative;\"><a href=\"#%E3%83%80%E3%83%B3%E3%83%97%E3%83%95%E3%82%A1%E3%82%A4%E3%83%AB%E3%81%8B%E3%82%89%E3%83%A1%E3%83%A2%E3%83%AA%E3%83%AA%E3%83%BC%E3%82%AF%E4%BA%8B%E8%B1%A1%E3%82%92%E8%AA%BF%E6%9F%BB%E3%81%99%E3%82%8B%E5%89%8D%E3%81%AE%E6%BA%96%E5%82%99\" aria-label=\"ダンプファイルからメモリリーク事象を調査する前の準備 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>ダンプファイルからメモリリーク事象を調査する前の準備</h2>\n<p>では、ダンプファイルの例外情報が役に立たない場合、どのように解析を進めていけばよいでしょうか。</p>\n<p>一般的に、ダンプファイルの取得前にある程度問題の原因箇所を絞りこんでおくことが重要です。</p>\n<p>例えば、今回の場合だとダンプファイルを解析する前に、 Process Explorer やタスクマネージャ、またはリソースモニターなどによってすでに D4C.exe のメモリリークが発生していることを特定済みであることを前提としています。</p>\n<p>また、ダンプファイルの解析を行う前には、D4C.exe のプロセスに割り当てられたメモリ領域のうち、具体的にどの領域が肥大化しているのかを特定しておくとよいでしょう。</p>\n<p>ユーザモードプロセスの仮想アドレス領域に割り当てられた各セクションについては、Sysinternals の VMMap を使用することで以下のように分類されていることを確認できます。<sup id=\"fnref-3\"><a href=\"#fn-3\" class=\"footnote-ref\">3</a></sup></p>\n<ul>\n<li>Image</li>\n<li>Mapped File</li>\n<li>Shareable</li>\n<li>Heap</li>\n<li>Managed Heap</li>\n<li>Stack</li>\n<li>Private Data</li>\n</ul>\n<p>Image 領域は実行可能なイメージなどをマッピングするために割り当てられています。</p>\n<p>また、Mapped File 領域はメモリにマッピングされたデータファイル用に割り当てられた領域です。</p>\n<p>Shareable 領域には、Image 領域や Mapped File 領域にマッピングされなかった共有可能なメモリが割り当てられます。</p>\n<p>Heap 領域はこのプロセスの所有するヒープ用のメモリ領域です。(Managed Heap は CLR によって割り当てられる領域なので、.Net を使用しないプロセスの場合には何も表示されません。)</p>\n<p>一般にユーザモードアプリケーションのメモリリークが発生する場合、この Heap 領域のサイズが増大します。</p>\n<p>そして、Stack 領域はプロセス内の各実行スレッドが持つスタック用の領域であり、Private Data 領域はスタックとヒープ以外のメモリ割り当てに使用されます。</p>\n<p>以下は、VMMap でアプリケーションのメモリリークが発生する前の状態の D4C.exe プロセスの情報を参照した結果です。</p>\n<p><span\n      class=\"gatsby-resp-image-wrapper\"\n      style=\"position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 500px; \"\n    >\n      <a\n    class=\"gatsby-resp-image-link\"\n    href=\"/static/4bef7df84701abff370d018678582621/0b533/mem-leak-004.png\"\n    style=\"display: block\"\n    target=\"_blank\"\n    rel=\"noopener\"\n  >\n    <span\n    class=\"gatsby-resp-image-background-image\"\n    style=\"padding-bottom: 76.25%; position: relative; bottom: 0; left: 0; background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAPCAYAAADkmO9VAAAACXBIWXMAAA7EAAAOxAGVKw4bAAAC8ElEQVQ4y5WSaW8bVRSG568CHyIkJNQC4k+AkIoQpUUhrWTauqkbB1rHdhwnXuIlduzJuN5m7PEyi+3xMt5IZEV5uJmGb1CVKz16z3vP0V2P1GhozJdzrq6uWK/XHqvViuVyyWKx8Pz19TX/Nm5ubjw2m43nNU1D6vQMdL1DS2t5qgk1DAPbtrEsi8lkguu6H2Q6m3kby7KMFK+Y1NU23U4HVVVptdpe0UwUzdzZe51N/5Op4HbTy8tLFEVB6ne73iK3k9Nbpu8L/g+O43i3yuVySEqoTOblgErIoRadU4241D6WqEs9PCN7viAl10kchZGqxwWqpRJ6q8/AcrDNEQNTaP8j6Y3EW48x7QHpVBKpFM5QzhXRVROjY9NvC3QD0+pj2ZbA/AB3ecsUz6aRTIoFm8cd5D9n4gozmrEFjeia5omBZXYZO2NGwyGT8VjEDs5o5PFPfJvz9C7OZDJIDfEhQ/GTY9Fz4/mcieg/WyzUaOk47gJjMOLsXKbdM5ku18I7XLyrM5rOGU5cSkoVrdNjebnhJCFOeBY7YNVtsO41GdZKqNljcqE90m+DuO13IlenmU3QVwr81W8yb1dpFU+ZqBXPd84z6OU8G7vNSSyKdPLgAfpTH8bvL+g9f4bt91P/7THpn37AfunHebVL+dcfqT3ZZhwIYPlfCP8zXVE7Eb6684iL7Ue4wSBHwT2kx74dHvqesh8/4jCXIl7MEhWn3D14xWE+xfF5ntfRIMGjN14cO0sTOo3f5XK8SUR4ffgHSblIKCLaJry3RXT/U9rK17Qu7gu+4jTyJeHAJ2jyPYzGN+TjW2RiW17cqdwnF/+CWvEepvDl1OckDj5joH3LYcSHlNj/jkb6IeO6H0t5hqsFaBeekHr7PY6Ym7cCdIo7NPPbTJu7Xp1e8mFVnjNTd71cJfULK32PbFKc0NDFL/e6LMcjTL2FWlGolUuUclkaFzJNRfa0pzZxjD6jfterHwod9XseQ8FE9GKxUOBv9OoibKxANlEAAAAASUVORK5CYII='); background-size: cover; display: block;\"\n  ></span>\n  <picture>\n          <source\n              srcset=\"/static/4bef7df84701abff370d018678582621/8ac56/mem-leak-004.webp 240w,\n/static/4bef7df84701abff370d018678582621/d3be9/mem-leak-004.webp 480w,\n/static/4bef7df84701abff370d018678582621/b0a15/mem-leak-004.webp 500w\"\n              sizes=\"(max-width: 500px) 100vw, 500px\"\n              type=\"image/webp\"\n            />\n          <source\n            srcset=\"/static/4bef7df84701abff370d018678582621/8ff5a/mem-leak-004.png 240w,\n/static/4bef7df84701abff370d018678582621/e85cb/mem-leak-004.png 480w,\n/static/4bef7df84701abff370d018678582621/0b533/mem-leak-004.png 500w\"\n            sizes=\"(max-width: 500px) 100vw, 500px\"\n            type=\"image/png\"\n          />\n          <img\n            class=\"gatsby-resp-image-image\"\n            src=\"/static/4bef7df84701abff370d018678582621/0b533/mem-leak-004.png\"\n            alt=\"VMMap で起動直後のプロセスを調査\"\n            title=\"VMMap で起動直後のプロセスを調査\"\n            loading=\"lazy\"\n            style=\"width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;\"\n          />\n        </picture>\n  </a>\n    </span></p>\n<p>2 番のメニューを選択してアプリケーションのメモリリーク事象を再現した後に VMMap の表示を更新すると、以下のようにプロセスのメモリ空間の中で Heap 領域(オレンジの領域)が大きく増大していることを確認できます。</p>\n<p><span\n      class=\"gatsby-resp-image-wrapper\"\n      style=\"position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 500px; \"\n    >\n      <a\n    class=\"gatsby-resp-image-link\"\n    href=\"/static/d473103086c66aec914de1aa5dd51b39/0b533/mem-leak-005.png\"\n    style=\"display: block\"\n    target=\"_blank\"\n    rel=\"noopener\"\n  >\n    <span\n    class=\"gatsby-resp-image-background-image\"\n    style=\"padding-bottom: 79.16666666666667%; position: relative; bottom: 0; left: 0; background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAQCAYAAAAWGF8bAAAACXBIWXMAAA7EAAAOxAGVKw4bAAADIklEQVQ4y5WUW08bVxSF5y9H6ktSVUKtmlISpahpmpshIEGwYwwkBWKbEIzxbYxvmEvAxmPP2AbMXD02xvTl62FCUR8aNX34tPZa++wzczSjIxXKu1i2iev2cBzHo9t1sG37lv7FBVdXVwyHw1v+6fv9PpeXlwwGA6SzkzbtdhtNa3rabH7WTqfjqW073sDXIkUKDY6OKlQrFQ4PPnF0eIRpGFgC09CxTOMzxr9wk9umiWNb3mmk49Y5SusUszdAd1wMt4/dv8QS/qvoDzgXc82Owem5jqSGZ1Hf+bA2gzjxEPbmvFdf63/hrYvP01mfo77wDCW+cb3hDLX5J5ysTuHEAtgb/v/F9Yy+Nksj9IT61gexYeQ19aUXGBsB8YbXTw5+mS/09Y9+1MVnaOk1pOYfPupzD9FXXmCHJzBXxfHf+3Aik0InRDaJuzZ1433emm50Clv0rn13bRpz+Sm1hZcotQZS+7CMo1Zu6bVqdLUq7YOi588rexznUpx82sHVjtGr+9SLMlb9ELt+JOoMrb0C/RONlvjlpEx+G2fg4ly4dCydqqqQKxVIyBlskbU6J2QLBWqaSm94IVQhX94RX9bE6Jrkd0scHFdxhz0UpYqUe/473aUQzmKQU/8M2vQrUuOPSIw/pCuys2CAou8pyswU7tI86txryhPPOQvMYi0E2Z30sffqJf2FN9STW0izU9OE5kKsRzZIbSXIy9sk4+uEV+bJJFLIqQzh5RAfIstkU7LIksQ+RsXauOdj61Eiq4vIyTRFcRLJP3uXN/67ZDPjbAvy2V+JhscIBr4lJ49TKjwmvDoi+J6dwm8ie8T78E+kE78I/5h4bJR3b0co5oQvRZA2V+5QTtxDV37mrHofq/GA/fQIyegdzPoo3eYDaqXv2JfvYatjoj/KcekHWof3RW8MbW+EXOwbHO1H1KrYUI6uoBYSGJUyWkmmXZapZjdJhd+KPE1TZEouQS2fpHNQ8NB2srR2c17dFqoU05zt5zht1JB6FwP6gyGDqz/RTQtF1ajfoPxNQ+W0c44trjir6woVCPVqgdPrYYhbSTdM/gJVY1U9Zy7DuQAAAABJRU5ErkJggg=='); background-size: cover; display: block;\"\n  ></span>\n  <picture>\n          <source\n              srcset=\"/static/d473103086c66aec914de1aa5dd51b39/8ac56/mem-leak-005.webp 240w,\n/static/d473103086c66aec914de1aa5dd51b39/d3be9/mem-leak-005.webp 480w,\n/static/d473103086c66aec914de1aa5dd51b39/b0a15/mem-leak-005.webp 500w\"\n              sizes=\"(max-width: 500px) 100vw, 500px\"\n              type=\"image/webp\"\n            />\n          <source\n            srcset=\"/static/d473103086c66aec914de1aa5dd51b39/8ff5a/mem-leak-005.png 240w,\n/static/d473103086c66aec914de1aa5dd51b39/e85cb/mem-leak-005.png 480w,\n/static/d473103086c66aec914de1aa5dd51b39/0b533/mem-leak-005.png 500w\"\n            sizes=\"(max-width: 500px) 100vw, 500px\"\n            type=\"image/png\"\n          />\n          <img\n            class=\"gatsby-resp-image-image\"\n            src=\"/static/d473103086c66aec914de1aa5dd51b39/0b533/mem-leak-005.png\"\n            alt=\"VMMap でメモリリーク事象発生後のプロセスを調査\"\n            title=\"VMMap でメモリリーク事象発生後のプロセスを調査\"\n            loading=\"lazy\"\n            style=\"width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;\"\n          />\n        </picture>\n  </a>\n    </span></p>\n<p>また、WinDbg でダンプファイルからプロセスのメモリ使用状況を確認する必要がある場合は、<code class=\"language-text\">!address</code> 拡張機能を使用できます。</p>\n<p><span\n      class=\"gatsby-resp-image-wrapper\"\n      style=\"position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 500px; \"\n    >\n      <a\n    class=\"gatsby-resp-image-link\"\n    href=\"/static/ce670f270a89aa946ed74ae531b1658b/0b533/mem-leak-007.png\"\n    style=\"display: block\"\n    target=\"_blank\"\n    rel=\"noopener\"\n  >\n    <span\n    class=\"gatsby-resp-image-background-image\"\n    style=\"padding-bottom: 66.66666666666666%; position: relative; bottom: 0; left: 0; background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAANCAYAAACpUE5eAAAACXBIWXMAAA7EAAAOxAGVKw4bAAACMElEQVQ4y1VU2XLaQBDU//9LEr/lLYkhFJc4dJCyIYBVBgE60IUkzNWeXiwKtmpqvetRT09PL1qSJHAcB1mWwXVd5HmO1WqFOI4RBAE8z8PlclH3h8MBRVFgt9vheDyiLEucz2dwMYdL46VlWQrAtm1EUYTBYIDpdIrhcIh+v68Sqw+Zv1wuFQF+Q+AHQFY2TVP90zAMkDH3VquFRqOBbreL+0XA9Xqt8n3fv90/ABLgHpAF2u02ms2mAtzv9wro4+NDtUxJCDabzR5aZtwAK2YVIP8mWK/Xw3a7VcGi1I9g1HcymdyYVUtjArWidtz5ETWkdp1OB7quI01TVYi6MZ+DIiAZkj2HRS1PpxO0OL4yC4UBQarWWd2UYRmG+cCALVNDFiFTntklg5JoaXptMRLAoTC7ng04b28YjUbigCvgpZqyAITCjoDckyRWdwcBUy1vhaFp2fDDLQbChueh7NPZXN0bpqUSD6czziJXXuzhvC9QlHtkeaHula2+Qqu/Bnj6a+PPvw2+10zUXnz8qFn42RnjqW7h27MBfbFH28nRfS/R+B/jl+2i/urjt7XAs71EbSTx4kGf+tAiYTSQYfhBCL3XR/TF0JZ2edZlylxHYcJ5ZqKVuxIfJinWmw0WS1eM7oqeAYIwhJZlqdLspqFMky/HkCK0De/ujVuW9KGrXMGnyldDX3reRgYaCaDYgFOlz2iXyoe0UFtsUz29CpDT5HQZ8/kc4/FYBX8POP1P/bjF8/bNr3cAAAAASUVORK5CYII='); background-size: cover; display: block;\"\n  ></span>\n  <picture>\n          <source\n              srcset=\"/static/ce670f270a89aa946ed74ae531b1658b/8ac56/mem-leak-007.webp 240w,\n/static/ce670f270a89aa946ed74ae531b1658b/d3be9/mem-leak-007.webp 480w,\n/static/ce670f270a89aa946ed74ae531b1658b/b0a15/mem-leak-007.webp 500w\"\n              sizes=\"(max-width: 500px) 100vw, 500px\"\n              type=\"image/webp\"\n            />\n          <source\n            srcset=\"/static/ce670f270a89aa946ed74ae531b1658b/8ff5a/mem-leak-007.png 240w,\n/static/ce670f270a89aa946ed74ae531b1658b/e85cb/mem-leak-007.png 480w,\n/static/ce670f270a89aa946ed74ae531b1658b/0b533/mem-leak-007.png 500w\"\n            sizes=\"(max-width: 500px) 100vw, 500px\"\n            type=\"image/png\"\n          />\n          <img\n            class=\"gatsby-resp-image-image\"\n            src=\"/static/ce670f270a89aa946ed74ae531b1658b/0b533/mem-leak-007.png\"\n            alt=\"!address コマンドの出力結果\"\n            title=\"!address コマンドの出力結果\"\n            loading=\"lazy\"\n            style=\"width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;\"\n          />\n        </picture>\n  </a>\n    </span></p>\n<p>上記のように、<code class=\"language-text\">!address</code> コマンドの出力結果からも、プロセス内で非常に多くのヒープ領域が確保されていることがわかります。</p>\n<p>ちなみに、<code class=\"language-text\">!address</code> コマンドの出力結果は非常に多いので、統計情報を収集できる <code class=\"language-text\">!address -summary</code> コマンドを使用するとより簡単に調査を行うことができます。</p>\n<p><span\n      class=\"gatsby-resp-image-wrapper\"\n      style=\"position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 500px; \"\n    >\n      <a\n    class=\"gatsby-resp-image-link\"\n    href=\"/static/d5430d2cbb67e423b10232465adedab3/0b533/mem-leak-008.png\"\n    style=\"display: block\"\n    target=\"_blank\"\n    rel=\"noopener\"\n  >\n    <span\n    class=\"gatsby-resp-image-background-image\"\n    style=\"padding-bottom: 87.5%; position: relative; bottom: 0; left: 0; background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAASCAYAAABb0P4QAAAACXBIWXMAAA7EAAAOxAGVKw4bAAACFUlEQVQ4y52Uh24CMRBE/f8fRRUCIUCAQPTee+9lozeRo1QpyUrOYZ/9PDu7F7fdbm25XNpms7HFYmHMH4+HEc/nU+Mv4SqVitVqNavX69bpdAQ9nU4fgH8Bu1QqZZlMRgPoer222+32LfA3wwEqFAqWz+cFbTQaNh6PNf4TbjAY2GQy0VitVvKT37PZTGoPh4Pt93vzXnu/mbO+2+00Zz+ZCXi9Xu1+v3+5jU2j0Ujvut2uRaNR+Y3PZNRqtazX69l0OrVSqSSw44+PzwW4XC5SSQAMBALWbDZtPp9bPB63drutgWrgAtIiAHj64eekANSrzWazNhwOBaA7AJMBl/b7fdnj0um06Ezwg5dAzuezVHEAMMBisag1gLQYcBTyjieeulwup4Xj8SgvgfEECJxCeWC5XJYS1gDQCdQApXgphYlEQlUFwkEKwOA3GwHR6Cjz2VAUUgbGb/ZVq9VXhVQH6RxCFUq5CSAKOICfqKLxWcMaYFzGWTLBGhiOVgiFQvKEdN8D2YwygKQUi8UEBYRVqPUfAgpV5XA4rP5ikZuQ/z5Ig8C7SCSiJwdJH5UoY/7WNiz6VqD7SRGlKASGvxSAi9jDfg4DZo5a9nn/BSQl/7X44tCL3nwyAMoaKXuLuCSZTAruPwyHwT8FN9MqHkjgWTAY1BeDv3wxiCIQ5n76V0Wgls10AqkRWECDow6LKAYd4BkvpTVS3FyJA2gAAAAASUVORK5CYII='); background-size: cover; display: block;\"\n  ></span>\n  <picture>\n          <source\n              srcset=\"/static/d5430d2cbb67e423b10232465adedab3/8ac56/mem-leak-008.webp 240w,\n/static/d5430d2cbb67e423b10232465adedab3/d3be9/mem-leak-008.webp 480w,\n/static/d5430d2cbb67e423b10232465adedab3/b0a15/mem-leak-008.webp 500w\"\n              sizes=\"(max-width: 500px) 100vw, 500px\"\n              type=\"image/webp\"\n            />\n          <source\n            srcset=\"/static/d5430d2cbb67e423b10232465adedab3/8ff5a/mem-leak-008.png 240w,\n/static/d5430d2cbb67e423b10232465adedab3/e85cb/mem-leak-008.png 480w,\n/static/d5430d2cbb67e423b10232465adedab3/0b533/mem-leak-008.png 500w\"\n            sizes=\"(max-width: 500px) 100vw, 500px\"\n            type=\"image/png\"\n          />\n          <img\n            class=\"gatsby-resp-image-image\"\n            src=\"/static/d5430d2cbb67e423b10232465adedab3/0b533/mem-leak-008.png\"\n            alt=\"!address -summary コマンドの出力結果\"\n            title=\"!address -summary コマンドの出力結果\"\n            loading=\"lazy\"\n            style=\"width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;\"\n          />\n        </picture>\n  </a>\n    </span></p>\n<p>このように、プロセスダンプをロードした WinDbg で <code class=\"language-text\">!address -summary</code> コマンドを実行することでも、プロセス内で割り当てられた Heap 領域が肥大化している状況を確認できます。</p>\n<p>これで、D4C.exe のメモリリーク事象は Heap 領域の肥大化が原因で発生している可能ことを特定できました。</p>\n<h2 id=\"プロセスダンプから-heap-領域を調査する\" style=\"position:relative;\"><a href=\"#%E3%83%97%E3%83%AD%E3%82%BB%E3%82%B9%E3%83%80%E3%83%B3%E3%83%97%E3%81%8B%E3%82%89-heap-%E9%A0%98%E5%9F%9F%E3%82%92%E8%AA%BF%E6%9F%BB%E3%81%99%E3%82%8B\" aria-label=\"プロセスダンプから heap 領域を調査する permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>プロセスダンプから Heap 領域を調査する</h2>\n<p>前項で、D4C.exe のメモリリーク事象の原因は、ユーザモードプロセス内の Heap 領域の肥大化であることを確認しました。</p>\n<p>Windows システムで稼働するアプリケーションはヒープマネージャと呼ばれるコンポーネントによって管理されており、一般的に Windows API の HeapCreate 関数<sup id=\"fnref-4\"><a href=\"#fn-4\" class=\"footnote-ref\">4</a></sup>や HeapAlloc 関数<sup id=\"fnref-5\"><a href=\"#fn-5\" class=\"footnote-ref\">5</a></sup>を使用してヒープの作成や割り当てを行います。<sup id=\"fnref-6\"><a href=\"#fn-6\" class=\"footnote-ref\">6</a></sup></p>\n<p>WinDbg でアプリケーションのプロセスダンプからヒープ領域の解析を行う場合には、<code class=\"language-text\">!heap</code> 拡張機能<sup id=\"fnref-7\"><a href=\"#fn-7\" class=\"footnote-ref\">7</a></sup>を使用できます。</p>\n<p>今回取得したメモリリーク事象発生時のプロセスダンプを WinDbg にロードし、<code class=\"language-text\">!heap</code> コマンドを実行したところ、以下のように 3 つの NT Heap がプロセス内に存在していることを確認できます。</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">0:000> !heap\n        Heap Address      NT/Segment Heap\n         1f1adb90000              NT Heap\n         1f1ada70000              NT Heap\n         1f1adf50000              NT Heap</code></pre></div>\n<p>NT Heap は Windows のアプリケーションで既定で使用されるヒープです。</p>\n<p>Windows アプリケーションが使用するヒープには NT Heap の他に Windows 10 / Windows Server 2016 から追加されたセグメントヒープがあります<sup id=\"fnref-8\"><a href=\"#fn-8\" class=\"footnote-ref\">8</a></sup>が、本書ではセグメントヒープは使用しないため、以降のヒープについてはすべて NT Heap を指すものとします。</p>\n<p><code class=\"language-text\">!heap</code> コマンドによってプロセス内に 3 つのヒープが存在することを確認できたので、次は <code class=\"language-text\">-S</code> オプションを使用して各ヒープの概要情報を表示します。</p>\n<p><span\n      class=\"gatsby-resp-image-wrapper\"\n      style=\"position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 500px; \"\n    >\n      <a\n    class=\"gatsby-resp-image-link\"\n    href=\"/static/d6de6d5e929e139c399f1533cc38ac87/0b533/app-heap-001.png\"\n    style=\"display: block\"\n    target=\"_blank\"\n    rel=\"noopener\"\n  >\n    <span\n    class=\"gatsby-resp-image-background-image\"\n    style=\"padding-bottom: 28.750000000000004%; position: relative; bottom: 0; left: 0; background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAGCAYAAADDl76dAAAACXBIWXMAAA7EAAAOxAGVKw4bAAAA5klEQVQY01VRyQqFQAyb//83N1QUVNz3fcODSx8pjPgOoSnTJg0jhmGgqqpoHEe6ruvFeZ5//X3f9DzPH77vEgJiQJ7nlGXZW4uioDRNKY5j7h3HIUVRSNM0hmEYlCQJv0dRxBwQlmWxCEQhACFwVVV5yfd9CoKAyrKktm2p6zpCqqZpaJ5nWteV67IszMW+71TXNQODcMEirgCHCXosQQwXwRTLMg1mUGEqEMU0TYZt26TrOotjCAMQRQ3DkEVlCnAYfa/myIjjeR4D8VzX5fPl0DRNfA364ziYI9W2bW8F8Kl939MP/R6/BIZRp1cAAAAASUVORK5CYII='); background-size: cover; display: block;\"\n  ></span>\n  <picture>\n          <source\n              srcset=\"/static/d6de6d5e929e139c399f1533cc38ac87/8ac56/app-heap-001.webp 240w,\n/static/d6de6d5e929e139c399f1533cc38ac87/d3be9/app-heap-001.webp 480w,\n/static/d6de6d5e929e139c399f1533cc38ac87/b0a15/app-heap-001.webp 500w\"\n              sizes=\"(max-width: 500px) 100vw, 500px\"\n              type=\"image/webp\"\n            />\n          <source\n            srcset=\"/static/d6de6d5e929e139c399f1533cc38ac87/8ff5a/app-heap-001.png 240w,\n/static/d6de6d5e929e139c399f1533cc38ac87/e85cb/app-heap-001.png 480w,\n/static/d6de6d5e929e139c399f1533cc38ac87/0b533/app-heap-001.png 500w\"\n            sizes=\"(max-width: 500px) 100vw, 500px\"\n            type=\"image/png\"\n          />\n          <img\n            class=\"gatsby-resp-image-image\"\n            src=\"/static/d6de6d5e929e139c399f1533cc38ac87/0b533/app-heap-001.png\"\n            alt=\"!heap -S コマンドでヒープの概要情報を表示\"\n            title=\"!heap -S コマンドでヒープの概要情報を表示\"\n            loading=\"lazy\"\n            style=\"width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;\"\n          />\n        </picture>\n  </a>\n    </span></p>\n<p><code class=\"language-text\">!heap -S</code> コマンドの出力結果を見ると、3 つのヒープのうち <code class=\"language-text\">0x1f1adb90000</code> のヒープのサイズが非常に大きくなっており、このヒープが肥大化していることがわかります。</p>\n<p>また、異なる観点での情報を得るため <code class=\"language-text\">!heap -a</code> コマンドを実行してみます。</p>\n<p><span\n      class=\"gatsby-resp-image-wrapper\"\n      style=\"position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 500px; \"\n    >\n      <a\n    class=\"gatsby-resp-image-link\"\n    href=\"/static/3a96e857210015c6994a2a0b58df3a4e/0b533/app-heap-002.png\"\n    style=\"display: block\"\n    target=\"_blank\"\n    rel=\"noopener\"\n  >\n    <span\n    class=\"gatsby-resp-image-background-image\"\n    style=\"padding-bottom: 27.500000000000004%; position: relative; bottom: 0; left: 0; background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAGCAYAAADDl76dAAAACXBIWXMAAA7EAAAOxAGVKw4bAAAA/UlEQVQY03WQzYqDQBCEff93UiEao4nGPxRB0ahoUIMiesuhluplYC870FbLdH9d01rbtqiqCr7v4/P5YNs28Hy/X8zzjHVdcZ4n9n3HcRxSw///jtb3PfI8RxRFCIIAWZYJqK5riWmaZCAHN02DsiwxjiPe77fosiwyhMFcI+R+v2MYBsRxDNM0BWwYBh6PB7qug67rUuN5HhzHQZqmopfLRYwkSSK9z+fzF3i9XsUNL23bFrUsS8Cv10samd9uN7iui6IoZABzglivXqjRBSFsVEBOosO/QAK4ZypXRBOsJTAMQwkB8kP7CkhnfAKVAO5OAdV6FJBBoHLJ+x9PpKUPK3X8mQAAAABJRU5ErkJggg=='); background-size: cover; display: block;\"\n  ></span>\n  <picture>\n          <source\n              srcset=\"/static/3a96e857210015c6994a2a0b58df3a4e/8ac56/app-heap-002.webp 240w,\n/static/3a96e857210015c6994a2a0b58df3a4e/d3be9/app-heap-002.webp 480w,\n/static/3a96e857210015c6994a2a0b58df3a4e/b0a15/app-heap-002.webp 500w\"\n              sizes=\"(max-width: 500px) 100vw, 500px\"\n              type=\"image/webp\"\n            />\n          <source\n            srcset=\"/static/3a96e857210015c6994a2a0b58df3a4e/8ff5a/app-heap-002.png 240w,\n/static/3a96e857210015c6994a2a0b58df3a4e/e85cb/app-heap-002.png 480w,\n/static/3a96e857210015c6994a2a0b58df3a4e/0b533/app-heap-002.png 500w\"\n            sizes=\"(max-width: 500px) 100vw, 500px\"\n            type=\"image/png\"\n          />\n          <img\n            class=\"gatsby-resp-image-image\"\n            src=\"/static/3a96e857210015c6994a2a0b58df3a4e/0b533/app-heap-002.png\"\n            alt=\"!heap -a コマンドでヒープのセグメント情報を表示\"\n            title=\"!heap -a コマンドでヒープのセグメント情報を表示\"\n            loading=\"lazy\"\n            style=\"width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;\"\n          />\n        </picture>\n  </a>\n    </span></p>\n<p><code class=\"language-text\">!heap -a</code> コマンドを実行してみると、<code class=\"language-text\">!heap -S</code> コマンドで確認した <code class=\"language-text\">0x1f1adb90000</code> のヒープに 84 個のセグメントが存在していることを確認できます。(<code class=\"language-text\">Segment at</code> から始まる行が 1 つのセグメントと対応します)</p>\n<p>Windows システムでは、NT Heap は <code class=\"language-text\">ntdll!_HEAP</code> 構造体によって管理されます。<sup id=\"fnref-9\"><a href=\"#fn-9\" class=\"footnote-ref\">9</a></sup></p>\n<p>プロセスダンプをロードした WinDbg で <code class=\"language-text\">dt ntdll!_HEAP</code> コマンドを実行して <code class=\"language-text\">ntdll!_HEAP</code> 構造体の情報を参照してみます。</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">0:000> dt ntdll!_HEAP\n  +0x000 Segment          : _HEAP_SEGMENT\n  +0x000 Entry            : _HEAP_ENTRY\n  +0x010 SegmentSignature : Uint4B\n  +0x014 SegmentFlags     : Uint4B\n  +0x018 SegmentListEntry : _LIST_ENTRY\n  +0x028 Heap             : Ptr64 _HEAP\n  +0x030 BaseAddress      : Ptr64 Void\n  +0x038 NumberOfPages    : Uint4B\n  +0x040 FirstEntry       : Ptr64 _HEAP_ENTRY\n  +0x048 LastValidEntry   : Ptr64 _HEAP_ENTRY\n{{ 省略 }}</code></pre></div>\n<p>上記のように、<code class=\"language-text\">ntdll!_HEAP</code> 構造体は <code class=\"language-text\">ntdll!_HEAP_SEGMENT</code> 構造体と <code class=\"language-text\">ntdll!_HEAP_ENTRY</code> 構造体から始まっています。</p>\n<p>さらに、<code class=\"language-text\">ntdll!_HEAP_SEGMENT</code> 構造体と <code class=\"language-text\">ntdll!_HEAP_ENTRY</code> 構造体の情報を参照してみます。</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\"># ntdll!_HEAP_SEGMENT の構造体情報をダンプ\n0:000> dt ntdll!_HEAP_SEGMENT\n +0x000 Entry            : _HEAP_ENTRY\n +0x010 SegmentSignature : Uint4B\n +0x014 SegmentFlags     : Uint4B\n +0x018 SegmentListEntry : _LIST_ENTRY\n +0x028 Heap             : Ptr64 _HEAP\n +0x030 BaseAddress      : Ptr64 Void\n +0x038 NumberOfPages    : Uint4B\n +0x040 FirstEntry       : Ptr64 _HEAP_ENTRY\n +0x048 LastValidEntry   : Ptr64 _HEAP_ENTRY\n +0x050 NumberOfUnCommittedPages : Uint4B\n +0x054 NumberOfUnCommittedRanges : Uint4B\n +0x058 SegmentAllocatorBackTraceIndex : Uint2B\n +0x05a Reserved         : Uint2B\n +0x060 UCRSegmentList   : _LIST_ENTRY\n\n# ntdll!_HEAP_ENTRY の構造体情報をダンプ\n0:000> dt ntdll!_HEAP_ENTRY \n +0x000 UnpackedEntry    : _HEAP_UNPACKED_ENTRY\n +0x000 PreviousBlockPrivateData : Ptr64 Void\n +0x008 Size             : Uint2B\n +0x00a Flags            : UChar\n +0x00b SmallTagIndex    : UChar\n +0x008 SubSegmentCode   : Uint4B\n +0x00c PreviousSize     : Uint2B\n +0x00e SegmentOffset    : UChar\n +0x00e LFHFlags         : UChar\n +0x00f UnusedBytes      : UChar\n +0x008 CompactHeader    : Uint8B\n +0x000 ExtendedEntry    : _HEAP_EXTENDED_ENTRY\n +0x000 Reserved         : Ptr64 Void\n +0x008 FunctionIndex    : Uint2B\n +0x00a ContextValue     : Uint2B\n +0x008 InterceptorValue : Uint4B\n +0x00c UnusedBytesLength : Uint2B\n +0x00e EntryOffset      : UChar\n +0x00f ExtendedBlockSignature : UChar\n +0x000 ReservedForAlignment : Ptr64 Void\n +0x008 Code1            : Uint4B\n +0x00c Code2            : Uint2B\n +0x00e Code3            : UChar\n +0x00f Code4            : UChar\n +0x00c Code234          : Uint4B\n +0x008 AgregateCode     : Uint8B</code></pre></div>\n<p>上記の情報から、<code class=\"language-text\">ntdll!_HEAP</code> 構造体は <code class=\"language-text\">ntdll!_HEAP_ENTRY</code> 構造体を含む <code class=\"language-text\">ntdll!_HEAP_SEGMENT</code> 構造体から構成されていることがわかります。</p>\n<p>Windows のバージョンが XP 以下の場合は、<code class=\"language-text\">ntdll!_HEAP_ENTRY</code> 構造体の Size の値を 8 倍したアドレスを加算していくことでプロセス内の特定のヒープセグメント内の <code class=\"language-text\">ntdll!_HEAP_ENTRY</code> 構造体を辿ることができます。<sup id=\"fnref-10\"><a href=\"#fn-10\" class=\"footnote-ref\">10</a></sup></p>\n<p>しかし、Vista 以降のバージョンでは ASLR によるプロセスヒープのランダム化が行われているため、この方法は使用できません。<sup id=\"fnref-11\"><a href=\"#fn-11\" class=\"footnote-ref\">11</a></sup></p>\n<p>そのため、ヒープセグメント内の <code class=\"language-text\">ntdll!_HEAP_ENTRY</code> 構造体を辿るためには、<code class=\"language-text\">!heap</code> 拡張機能を使用します。</p>\n<p>まずは、今回肥大化が発生しているヒープのアドレスである <code class=\"language-text\">0x1f1adb90000</code> を指定し、<code class=\"language-text\">!heap -a 0x1f1adb90000</code> コマンドによってこのヒープ内の情報を取得しました。(ヒープの ID を使用して <code class=\"language-text\">!heap -a 1</code> コマンドを実行することでも同等の出力を得られます。)</p>\n<p>このコマンドの出力結果は非常に多いので、必要に応じて <code class=\"language-text\">.logopen</code> コマンドによるファイルへの出力設定を実施しておくと良いでしょう。(<code class=\"language-text\">.logopen</code> コマンドについては本書の「付録A: WinDbg の Tips」に記載しています。)</p>\n<p>実際にプロセスダンプをロードした WinDbg で <code class=\"language-text\">!heap -a 0x1f1adb90000</code> コマンドを実行してみると、このヒープ内の 84 個のヒープセグメントと、その中のヒープエントリを列挙することができました。</p>\n<p>以下は、84 番目のヒープセグメントとその中のヒープエントリに関する出力結果です。</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\"># 84 番目のヒープセグメントとその中のヒープエントリに関する出力結果のみ抜粋\nSegment83 at fbec0000:\n  Flags:           00000000\n  Base:            1f1fbec0000\n  First Entry:     fbec0070\n  Last Entry:      1f1fce8f000\n  Total Pages:     00000fcf\n  Total UnCommit:  00000b5b\n  Largest UnCommit:00000000\n  UnCommitted Ranges: (1)\n\nHeap entries for Segment83 in Heap 000001f1adb90000\n  address: psize . size  flags   state (requested size)\n  000001f1fbec0000: 00000 . 00070 [101] - busy (6f)\n  000001f1fbec0070: 00070 . 41f90 [101] - busy (41f80) Internal \n  000001f1fbf02000: 41f90 . 42010 [101] - busy (41ff0) Internal \n  000001f1fbf44010: 42010 . 41ff0 [101] - busy (41fe0) Internal \n  000001f1fbf86000: 41ff0 . 42010 [101] - busy (41ff0) Internal \n  000001f1fbfc8010: 42010 . 41ff0 [101] - busy (41fe0) Internal \n  000001f1fc00a000: 41ff0 . 42010 [101] - busy (41ff0) Internal \n  000001f1fc04c010: 42010 . 00400 [101] - busy (3f0) Internal \n  000001f1fc04c410: 00400 . 41bf0 [101] - busy (41be0) Internal \n  000001f1fc08e000: 41bf0 . 42010 [101] - busy (41ff0) Internal \n  000001f1fc0d0010: 42010 . 41ff0 [101] - busy (41fe0) Internal \n  000001f1fc112000: 41ff0 . 42010 [101] - busy (41ff0) Internal \n  000001f1fc154010: 42010 . 41ff0 [101] - busy (41fe0) Internal \n  000001f1fc196000: 41ff0 . 42010 [101] - busy (41ff0) Internal \n  000001f1fc1d8010: 42010 . 41ff0 [101] - busy (41fe0) Internal \n  000001f1fc21a000: 41ff0 . 42010 [101] - busy (41ff0) Internal \n  000001f1fc25c010: 42010 . 41ff0 [101] - busy (41fe0) Internal \n  000001f1fc29e000: 41ff0 . 42010 [101] - busy (41ff0) Internal \n  000001f1fc2e0010: 42010 . 41ff0 [101] - busy (41fe0) Internal \n  000001f1fc322000: 41ff0 . 11fc0 [100]\n  000001f1fc333fc0: 11fc0 . 00040 [111] - busy (3d)\n  000001f1fc334000:      00b5b000      - uncommitted bytes.</code></pre></div>\n<p>プログラムがプロセスが割り当てたヒープに情報を書き込む場合、書き込まれたデータは、各ヒープエントリのヘッダ以降のメモリ領域に記録されます。<sup id=\"fnref-12\"><a href=\"#fn-12\" class=\"footnote-ref\">12</a></sup></p>\n<p>実際に、<code class=\"language-text\">!heap -a 0x1f1adb90000</code> コマンドで特定したいくつかのヒープエントリのアドレスを指定して 0x100 程度のメモリをダンプしてみると、以下のように <code class=\"language-text\">==> Allocated addr: &lt;Address></code> という文字列が各ヒープエントリに書き込まれていることを特定できます。</p>\n<p><span\n      class=\"gatsby-resp-image-wrapper\"\n      style=\"position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 500px; \"\n    >\n      <a\n    class=\"gatsby-resp-image-link\"\n    href=\"/static/559c07717c204960e7c18d7858c7fc1d/0b533/app-heap-003.png\"\n    style=\"display: block\"\n    target=\"_blank\"\n    rel=\"noopener\"\n  >\n    <span\n    class=\"gatsby-resp-image-background-image\"\n    style=\"padding-bottom: 97.91666666666667%; position: relative; bottom: 0; left: 0; background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAUCAYAAACNiR0NAAAACXBIWXMAAA7EAAAOxAGVKw4bAAACZElEQVQ4y22Uh3JqMQxE+f+vAgKB0HsNhFBT6DVAQJmjN0sub8KMx8LXXq20a4dKpZLV63VLpVLWaDQ8LpfL1m637f393YbDofX7fXt7e/MxGo18fTwe29fXl12vVzscDjabzez7+9tCuVzOKpWKRSIRGwwG1mq1HLhWq/ngWz6f97harXqyZrNpxWLRQfjtdjsfgIfYDKt4PG69Xs8Bn5+f/VCn0/GYBMz8Z11Jl8ulbTYbm06nNplMHNQZkjkajTog4AzWxJS2AMSAsWYYAtbtdj0h4M6Qw/SQXrEREEpTTylPSfiuPsMo+POS1cPHx0fvIYd0QH1TD9kHW2KSwAghjsejnc/nf6LwgQ3JZPLWbCkvhSmJZK+vrz6IaY9UBgilHVCiJBIJbzoxCQDnML1hAAD4y8uLA7K2Xq+dHaV/fHz82oZeoTIHUJAhcSSK/quHsg0M9/u9g91sAxt6+JdtMDgJmbWutfl8bp+fn7fKFovFL8NYLHZnG5UtMwOib8SswZCymWkPPb0xpGQWdUPkw79sIx9ut1u7XC6uMIP4jiFqspGD6hvghULhBggzYr7rugHG7IBkBzCdTvscLBHluFLYR4+DBo+DrAIgnjydThbKZrOeEYaUTDkqmwQyM7GuIsKRlJcHMMTgBbpTGR9iG/kOhnocSKhHgVjzarVyhjwSKO4+FMOHhwc3rZgFHwc9WWIv5jwMMJMbAA7RcDI+PT15ycHS2EgswKCdpHLwLrsomUzGN4XDYS+RfrEZsWQTPXEAax0i/9vGS+YAQJSOmroRsA72ULdG67DENoCgrgB/AASFoYQ4uqxvAAAAAElFTkSuQmCC'); background-size: cover; display: block;\"\n  ></span>\n  <picture>\n          <source\n              srcset=\"/static/559c07717c204960e7c18d7858c7fc1d/8ac56/app-heap-003.webp 240w,\n/static/559c07717c204960e7c18d7858c7fc1d/d3be9/app-heap-003.webp 480w,\n/static/559c07717c204960e7c18d7858c7fc1d/b0a15/app-heap-003.webp 500w\"\n              sizes=\"(max-width: 500px) 100vw, 500px\"\n              type=\"image/webp\"\n            />\n          <source\n            srcset=\"/static/559c07717c204960e7c18d7858c7fc1d/8ff5a/app-heap-003.png 240w,\n/static/559c07717c204960e7c18d7858c7fc1d/e85cb/app-heap-003.png 480w,\n/static/559c07717c204960e7c18d7858c7fc1d/0b533/app-heap-003.png 500w\"\n            sizes=\"(max-width: 500px) 100vw, 500px\"\n            type=\"image/png\"\n          />\n          <img\n            class=\"gatsby-resp-image-image\"\n            src=\"/static/559c07717c204960e7c18d7858c7fc1d/0b533/app-heap-003.png\"\n            alt=\"ヒープエントリのアドレスのメモリ情報をダンプ\"\n            title=\"ヒープエントリのアドレスのメモリ情報をダンプ\"\n            loading=\"lazy\"\n            style=\"width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;\"\n          />\n        </picture>\n  </a>\n    </span></p>\n<h2 id=\"メモリリークの原因箇所を特定する\" style=\"position:relative;\"><a href=\"#%E3%83%A1%E3%83%A2%E3%83%AA%E3%83%AA%E3%83%BC%E3%82%AF%E3%81%AE%E5%8E%9F%E5%9B%A0%E7%AE%87%E6%89%80%E3%82%92%E7%89%B9%E5%AE%9A%E3%81%99%E3%82%8B\" aria-label=\"メモリリークの原因箇所を特定する permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>メモリリークの原因箇所を特定する</h2>\n<p>ダンプファイルから割り当てられたヒープ領域の解析を行った結果、<code class=\"language-text\">==> Allocated addr: &lt;Address></code> という文字列が格納されたヒープ領域が解放されていないためにメモリリークが発生している可能性が高いことを特定しました。</p>\n<p>メモリリークのような問題は、よほど断続的にメモリの割り当てが発生していない限り、ダンプファイルの採取時のコールスタックに情報が記録されることは稀です。</p>\n<p>そのため、基本的にはダンプファイルの解析よりも、ライブデバッグやソースコードの参照、またはアプリケーションのリバースエンジニアリングによる解析を行う方が効率的な場合が多いです。</p>\n<p>ただし、本書ではできる限りダンプファイルの解析を通してメモリリークの発生原因となる処理を特定していきます。</p>\n<p>まず、WinDbg でプロセスダンプファイルをロードした状態で <code class=\"language-text\">k</code> コマンドを実行してスタックバックトレースを出力してみます。</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">0:000> k\n # Child-SP          RetAddr               Call Site\n00 0000003d`d1eff6e8 00007ffa`382d30ce     ntdll!NtWaitForSingleObject+0x14\n01 0000003d`d1eff6f0 00007ff6`dfe213b9     KERNELBASE!WaitForSingleObjectEx+0x8e\n02 0000003d`d1eff790 00007ff6`dfe21a40     D4C+0x13b9\n03 0000003d`d1effa50 00007ffa`38b17344     D4C+0x1a40\n04 0000003d`d1effa90 00007ffa`3a9c26b1     kernel32!BaseThreadInitThunk+0x14\n05 0000003d`d1effac0 00000000`00000000     ntdll!RtlUserThreadStart+0x21</code></pre></div>\n<p>残念ながら、ヒープの割り当てに使用される HeapAlloc 関数などの呼び出しはスタックバックトレースには記録されていませんでした。</p>\n<p>しかし、4 章や 5 章では扱いませんでしたが、一般的なアプリケーションの多くはマルチスレッドで実行されています。</p>\n<p>WinDbg にプロセスダンプをロードした状態で <code class=\"language-text\">k</code> コマンドを実行した際に取得できる情報は、プロセスのメインスレッドのスタックバックトレースのみですので、念のため他のスレッドのスタックバックトレースも調査してみましょう。</p>\n<p>ユーザモードプロセス内で稼働するスレッドは <code class=\"language-text\">!threads</code> 拡張機能<sup id=\"fnref-13\"><a href=\"#fn-13\" class=\"footnote-ref\">13</a></sup>を使用することで列挙できます。</p>\n<p><span\n      class=\"gatsby-resp-image-wrapper\"\n      style=\"position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 500px; \"\n    >\n      <a\n    class=\"gatsby-resp-image-link\"\n    href=\"/static/0ec34578939c0d4a8e075bd68e7e903c/0b533/app-memleak-thread-001.png\"\n    style=\"display: block\"\n    target=\"_blank\"\n    rel=\"noopener\"\n  >\n    <span\n    class=\"gatsby-resp-image-background-image\"\n    style=\"padding-bottom: 6.666666666666667%; position: relative; bottom: 0; left: 0; background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAABCAYAAADeko4lAAAACXBIWXMAAA7EAAAOxAGVKw4bAAAAR0lEQVQI1x3KMQoAIQwAwfv/86xMQEkhhFgoWtiueN0y7NdaI6VErZVSCjln5pyYGarKWov3PH/t7ogIYwwi4vfeO3tvzjlcfZtJYFp4Q4cAAAAASUVORK5CYII='); background-size: cover; display: block;\"\n  ></span>\n  <picture>\n          <source\n              srcset=\"/static/0ec34578939c0d4a8e075bd68e7e903c/8ac56/app-memleak-thread-001.webp 240w,\n/static/0ec34578939c0d4a8e075bd68e7e903c/d3be9/app-memleak-thread-001.webp 480w,\n/static/0ec34578939c0d4a8e075bd68e7e903c/b0a15/app-memleak-thread-001.webp 500w\"\n              sizes=\"(max-width: 500px) 100vw, 500px\"\n              type=\"image/webp\"\n            />\n          <source\n            srcset=\"/static/0ec34578939c0d4a8e075bd68e7e903c/8ff5a/app-memleak-thread-001.png 240w,\n/static/0ec34578939c0d4a8e075bd68e7e903c/e85cb/app-memleak-thread-001.png 480w,\n/static/0ec34578939c0d4a8e075bd68e7e903c/0b533/app-memleak-thread-001.png 500w\"\n            sizes=\"(max-width: 500px) 100vw, 500px\"\n            type=\"image/png\"\n          />\n          <img\n            class=\"gatsby-resp-image-image\"\n            src=\"/static/0ec34578939c0d4a8e075bd68e7e903c/0b533/app-memleak-thread-001.png\"\n            alt=\"!threads コマンドの実行結果\"\n            title=\"!threads コマンドの実行結果\"\n            loading=\"lazy\"\n            style=\"width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;\"\n          />\n        </picture>\n  </a>\n    </span></p>\n<p>今回の解析対象のプロセスダンプをロードした状態で <code class=\"language-text\">!threads</code> コマンドを実行すると、上記のようにメインスレッド(ID:0 のスレッド)に加えて、2 つのスレッドが作成されていることを確認できます。(<code class=\"language-text\">!threads</code> コマンド実行時に <code class=\"language-text\">No export threads found</code> が表示される場合は、一度 <code class=\"language-text\">!analyze -v</code> コマンドを実行してみてください)</p>\n<p>現在のプロセスコンテキストで稼働するすべてのスレッドのスタックバックトレースを参照したい場合、<code class=\"language-text\">~*k</code> コマンドを使用します。</p>\n<p>また、<code class=\"language-text\">~1k</code> や <code class=\"language-text\">~2k</code> のように、特定のスレッドのインデックスを指定することも可能です。</p>\n<p>さらに、特定のスレッドのインデックスを指定して <code class=\"language-text\">~1s</code> や <code class=\"language-text\">~2s</code> コマンドを実行することで、現在のスレッドコンテキストを変更することも可能です。</p>\n<p>つまり、<code class=\"language-text\">~1s; k</code> コマンドを実行することでも、<code class=\"language-text\">~1k</code> コマンドと同じく、インデックスが 1 のスレッドのスタックバックトレースを参照することが可能です。</p>\n<br>\n<p>~s (現在のスレッドの設定):</p>\n<p><a href=\"https://learn.microsoft.com/ja-jp/windows-hardware/drivers/debugger/-s--set-current-thread-\" target=\"_blank\" rel=\"nofollow noopener noreferrer\">https://learn.microsoft.com/ja-jp/windows-hardware/drivers/debugger/-s—set-current-thread-</a></p>\n<br>\n<p>今回は <code class=\"language-text\">~*k</code> コマンドによってすべてのスレッドのスタックバックトレースをまとめて出力してみます。</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">0:000> ~*k\n\n.  0  Id: 159c.10d4 Suspend: 0 Teb: 0000003d`d1ce8000 Unfrozen\n # Child-SP          RetAddr               Call Site\n00 0000003d`d1eff6e8 00007ffa`382d30ce     ntdll!NtWaitForSingleObject+0x14\n01 0000003d`d1eff6f0 00007ff6`dfe213b9     KERNELBASE!WaitForSingleObjectEx+0x8e\n02 0000003d`d1eff790 00007ff6`dfe21a40     D4C+0x13b9\n03 0000003d`d1effa50 00007ffa`38b17344     D4C+0x1a40\n04 0000003d`d1effa90 00007ffa`3a9c26b1     kernel32!BaseThreadInitThunk+0x14\n05 0000003d`d1effac0 00000000`00000000     ntdll!RtlUserThreadStart+0x21\n\n   1  Id: 159c.2390 Suspend: 0 Teb: 0000003d`d1cf0000 Unfrozen\n # Child-SP          RetAddr               Call Site\n00 0000003d`d22fe838 00007ffa`382fb4ee     ntdll!NtDelayExecution+0x14\n01 0000003d`d22fe840 00007ff6`dfe21680     KERNELBASE!SleepEx+0x9e\n02 0000003d`d22fe8e0 00007ffa`38b17344     D4C+0x1680\n03 0000003d`d22ff930 00007ffa`3a9c26b1     kernel32!BaseThreadInitThunk+0x14\n04 0000003d`d22ff960 00000000`00000000     ntdll!RtlUserThreadStart+0x21\n\n   2  Id: 159c.1018 Suspend: 0 Teb: 0000003d`d1cf2000 Unfrozen\n # Child-SP          RetAddr               Call Site\n00 0000003d`d23fea68 00007ffa`382fb4ee     ntdll!NtDelayExecution+0x14\n01 0000003d`d23fea70 00007ff6`dfe21680     KERNELBASE!SleepEx+0x9e\n02 0000003d`d23feb10 00007ffa`38b17344     D4C+0x1680\n03 0000003d`d23ffb60 00007ffa`3a9c26b1     kernel32!BaseThreadInitThunk+0x14\n04 0000003d`d23ffb90 00000000`00000000     ntdll!RtlUserThreadStart+0x21</code></pre></div>\n<p>上記の出力結果から、インデックスが 1 と 2 のスレッドがそれぞれ同じように <code class=\"language-text\">D4C+0x1680</code> から <code class=\"language-text\">KERNELBASE!SleepEx</code> 関数を呼び出していることがわかります。</p>\n<p>しかし、このままではどのスレッドから解析を進めるべきかを決められません。</p>\n<p>そのため、少し違うアプローチで各スレッドの情報を調査してみましょう。</p>\n<p>WinDbg では <code class=\"language-text\">!runaway</code> 拡張機能<sup id=\"fnref-14\"><a href=\"#fn-14\" class=\"footnote-ref\">14</a></sup>を使用することで各スレッドによって消費された時間に関する情報を取得できます。</p>\n<p>今回取得したダンプファイルをロードした WinDbg で <code class=\"language-text\">!runaway 7</code> コマンドを実行してみると以下の出力を得られます。(<code class=\"language-text\">7</code> は、<code class=\"language-text\">!runaway</code> 拡張機能を使用してユーザモードで消費した時間、およびカーネルモードで消費した時間、そして各スレッドが作成されてから経過した時間のすべての情報を出力するためのオプションフラグです)</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">0:000> !runaway 7\n\nUser Mode Time\nThread       Time\n  1:2390     0 days 0:00:27.031\n  2:1018     0 days 0:00:11.093\n  0:10d4     0 days 0:00:00.000\n\nKernel Mode Time\nThread       Time\n  1:2390     0 days 0:01:38.703\n  2:1018     0 days 0:00:01.703\n  0:10d4     0 days 0:00:00.000\n\nElapsed Time\nThread       Time\n  0:10d4     0 days 0:30:53.547\n  1:2390     0 days 0:30:45.242\n  2:1018     0 days 0:30:45.242</code></pre></div>\n<p>上記の <code class=\"language-text\">!runaway 7</code> コマンドの出力結果を参照すると、インデックス 1 のスレッドが極端に多くのカーネル時間を消費していることがわかります。</p>\n<p>一般に、メモリリークなどのシステムパフォーマンスに関わる問題は、より多くのシステムリソースを消費しているスレッド(=より多くの実行時間を消費しているスレッド)の動作に起因していることが多いです。</p>\n<p>また、ヒープの割り当てなど、メモリの操作に関わる処理は基本的にカーネルモードで実行されます。</p>\n<p>そのため、より多くのカーネル時間を消費しているインデックス 1 のスレッドが問題の原因である可能性が高いため、優先的に調査を実施していくことにします。</p>\n<p>ちなみに、プロセス内で稼働するスレッドの数や実行時間については、WinDbg を使用しなくても Process Explorer などのツールから調査することが可能です。</p>\n<p>Process Explorer を使用する場合は、ダンプファイルを取得した際と同じく管理者権限で Process Explorer を起動し、D4C.exe のプロセスを右クリックします。</p>\n<p>そして、[Properties..] をクリックした後 [Threads] タブを開くことで、以下のようにプロセス内で稼働するスレッドの情報を参照できます。</p>\n<p><span\n      class=\"gatsby-resp-image-wrapper\"\n      style=\"position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 500px; \"\n    >\n      <a\n    class=\"gatsby-resp-image-link\"\n    href=\"/static/d25c587fd083cbb96a9b87ad7e7ee23b/0b533/app-memleak-proexp-001.png\"\n    style=\"display: block\"\n    target=\"_blank\"\n    rel=\"noopener\"\n  >\n    <span\n    class=\"gatsby-resp-image-background-image\"\n    style=\"padding-bottom: 129.58333333333334%; position: relative; bottom: 0; left: 0; background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAaCAYAAAC3g3x9AAAACXBIWXMAAA7EAAAOxAGVKw4bAAADhElEQVRIx9VVyY7bRhDV7xoI4AS55OAEMHLIIR+Qj0hgewzfcspJ4yDWzHg2LVzEnaIoShRFUaSGeqlXGtkTR4PEuaWAApvVXdXVtbzq3NoBxo4Dz/cxHA1lPYY1tjBJEtR1jaqq9NsI1/dM2Xq9xmazwXK5xHw+V5lt2+ik2QKTyQTT6VQ3+PUDH7HIqLRarZCmM+EUs1mqayrTUJJM9WLql3LWdR10oihEr9fDO2Eeur3t4+LiAoZh4PLyCnEc4/Tt7+idnele9/QU1ze3CALqnWE0MlS33+/DNE106NV4bCMIQ/Xo7u4Obdtiu92iKAp9YiFe8nlNs9UzeZ7rP5nny3Kt8vF4jA6VynWFdJbpBp+6qRs9EEaxPD9SeZZlcBwXYRhJaBbi+UTiHmCWzXEnDrTtbh9DL1ngx18jfPfawZevfHx7YuPp6wm+eRPh+xMDz18O8fVJgC9e+Hjys4Mnv7j46qWL5ycWnr0w8MMbOf8qxE/dOQJHDBarEkPLQ+/axDSv4MYZlpsdslUDN0pheDHSolZZXrUQMcJ0jm7vEn+87+O3bg9ukqPaApZl7Z/c1Btsmxr/mnYt6mqNal0q85+kBplZxkDP7XZ/4/aIbHfsDpF/NCiZ+tQgHlF67GJuHTX4ubTX+V8aPB6Xz+MPBtv/4Nkx+mBwVZbIFwtFG/JC1mS224Ef7lFnucx1TTRi7zdNszfIRnddT1HDcV14ngdTNixLACMIpJcD6d9Q5a7sj0YjnJ9f4PLqCoPBEFfyNQxToUzBgQZ934Mtjd/eV/x0mihItBLbSjqC3hyIHhHaXLmAHtu2JXB2o14rHlLoei4y+R6yHQpGGpapnhM8J5NYkYdPJLiSDmcfkiPI36GhkbjMGyvBN1IgiD00RzAEMLf3itc3fdyIJwxHLt4Q0g5l0963rhokthF9HXGXME6K40gUTcU+EsGW8WSMl8U+CdybSbJIfzHIGDLQQcgEhKJQyNyYYiAyHmAFEDwHw6FAvKVfynjJ0ScXaiAVlP4IXwxwOpshkeQQyZkIjglfJqMvF89ZOqK32dRYi3HaIGKpwVIED9vo0/Zj8DmAzmVwsSwKybilCXOQyRQcDPZDTZMrIenMxBN6xKf/E7N8PEF005vAdCM40X68Mr4cvyynDheLB13yGLMalvkCAzfF2+sxuu9lzNoJAqlhjlFWBF/yJ2KGtBuH0SWpAAAAAElFTkSuQmCC'); background-size: cover; display: block;\"\n  ></span>\n  <picture>\n          <source\n              srcset=\"/static/d25c587fd083cbb96a9b87ad7e7ee23b/8ac56/app-memleak-proexp-001.webp 240w,\n/static/d25c587fd083cbb96a9b87ad7e7ee23b/d3be9/app-memleak-proexp-001.webp 480w,\n/static/d25c587fd083cbb96a9b87ad7e7ee23b/b0a15/app-memleak-proexp-001.webp 500w\"\n              sizes=\"(max-width: 500px) 100vw, 500px\"\n              type=\"image/webp\"\n            />\n          <source\n            srcset=\"/static/d25c587fd083cbb96a9b87ad7e7ee23b/8ff5a/app-memleak-proexp-001.png 240w,\n/static/d25c587fd083cbb96a9b87ad7e7ee23b/e85cb/app-memleak-proexp-001.png 480w,\n/static/d25c587fd083cbb96a9b87ad7e7ee23b/0b533/app-memleak-proexp-001.png 500w\"\n            sizes=\"(max-width: 500px) 100vw, 500px\"\n            type=\"image/png\"\n          />\n          <img\n            class=\"gatsby-resp-image-image\"\n            src=\"/static/d25c587fd083cbb96a9b87ad7e7ee23b/0b533/app-memleak-proexp-001.png\"\n            alt=\"Process Explorer でスレッドの情報を参照する\"\n            title=\"Process Explorer でスレッドの情報を参照する\"\n            loading=\"lazy\"\n            style=\"width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;\"\n          />\n        </picture>\n  </a>\n    </span></p>\n<h2 id=\"各スレッドが実行している処理を解析する\" style=\"position:relative;\"><a href=\"#%E5%90%84%E3%82%B9%E3%83%AC%E3%83%83%E3%83%89%E3%81%8C%E5%AE%9F%E8%A1%8C%E3%81%97%E3%81%A6%E3%81%84%E3%82%8B%E5%87%A6%E7%90%86%E3%82%92%E8%A7%A3%E6%9E%90%E3%81%99%E3%82%8B\" aria-label=\"各スレッドが実行している処理を解析する permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>各スレッドが実行している処理を解析する</h2>\n<p>ここまでの調査では、D4C.exe のメモリリーク事象について以下の情報を特定することができました。</p>\n<ul>\n<li>D4C.exe のプロセスのヒープ領域が肥大化している</li>\n<li>大量に確保されたまま解放されていないヒープエントリのメモリ内には、<code class=\"language-text\">==> Allocated addr: &lt;Address></code> という文字列が書き込まれている</li>\n<li>D4C.exe のプロセス内では 3 つのスレッドが稼働しており、特にインデックス 1 のスレッドが極端にカーネルモードでの実行時間を消費している</li>\n</ul>\n<p>ここから、実際にプロセスのヒープ領域を肥大化させてメモリリークを引き起こしている処理を特定していきます。</p>\n<p>しかし、これまでに行ったクラッシュ事象の解析とは異なり、ユーザが任意のタイミングで取得したダンプファイルには、都合よく問題を引き起こす処理の実行に関する情報が記録されているとは限りません。</p>\n<p>これは、ダンプファイルに含まれる情報は、あくまでダンプファイル採取時点のメモリの情報に過ぎないためです。</p>\n<p>このような場合にヒープ領域への書き込みを行う処理を特定するためには、ライブデバッグやソースコードの解析を行うか、4 章や 5 章で使用した Ghidra などのデコンパイラを使用する方が効果的です。</p>\n<p>ヒープ領域への書き込みを行う処理を特定する方法は複数考えられますが、本書では以下のアプローチで解析を進めていくことにします。</p>\n<ol>\n<li>アプリケーションのデータ領域の中から、<code class=\"language-text\">==> Allocated addr:</code> という文字列がハードコードされているオフセットを特定する。</li>\n<li>デコンパイラを使用して [1.] で特定したオフセットのデータを参照しているコードを特定することで、<code class=\"language-text\">==> Allocated addr: &lt;Address></code> という文字列をメモリに書き込んでいる処理を特定する。</li>\n</ol>\n<p>ここまでの項で確認した通り、今回割り当てられているヒープ領域のメモリ内には <code class=\"language-text\">==> Allocated addr: &lt;Address></code> という文字列が書き込まれておりますが、<code class=\"language-text\">==> Allocated addr:</code> の部分はどのヒープ領域でも不変でした。</p>\n<p>つまり、プログラムで難読化が行われていない限り、<code class=\"language-text\">==> Allocated addr:</code> というテキストがプログラム内にハードコードされている可能性が高いと推察できます。</p>\n<p>プログラムにハードコードされたテキストなどのデータは通常、実行プロセスの中の <code class=\"language-text\">.rdata</code> 領域(読み取り専用の初期化データ)に展開されます。<sup id=\"fnref-15\"><a href=\"#fn-15\" class=\"footnote-ref\">15</a></sup></p>\n<p>そのため、まずはプロセスダンプファイルをロードしている WinDbg で <code class=\"language-text\">.rdata</code> 領域をスキャンして <code class=\"language-text\">==> Allocated addr:</code> というテキストがハードコードされてるアドレスを特定していきます。</p>\n<p><code class=\"language-text\">.rdata</code> 領域をスキャンするためには対象のアドレスを特定する必要があるので、まずは <code class=\"language-text\">!dh -s</code> コマンドを使用して D4C.exe のセクションヘッダの情報を表示しましょう。</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">0:000> !dh -s !D4C\n\nSECTION HEADER #1\n .text name\n  15EC virtual size\n  1000 virtual address\n  1600 size of raw data\n   400 file pointer to raw data\n     0 file pointer to relocation table\n     0 file pointer to line numbers\n     0 number of relocations\n     0 number of line numbers\n60000020 flags\n       Code\n       (no align specified)\n       Execute Read\n\nSECTION HEADER #2\n.rdata name\n  343A virtual size\n  3000 virtual address\n  3600 size of raw data\n  1A00 file pointer to raw data\n     0 file pointer to relocation table\n     0 file pointer to line numbers\n     0 number of relocations\n     0 number of line numbers\n40000040 flags\n       Initialized Data\n       (no align specified)\n       Read Only\n\n{{ 省略 }}\n\nSECTION HEADER #3\n .data name\n   638 virtual size\n  7000 virtual address\n   200 size of raw data\n  5000 file pointer to raw data\n     0 file pointer to relocation table\n     0 file pointer to line numbers\n     0 number of relocations\n     0 number of line numbers\nC0000040 flags\n       Initialized Data\n       (no align specified)\n       Read Write\n\n{{ 省略 }}</code></pre></div>\n<p>今回のプロセスダンプをロードしている WinDbg で <code class=\"language-text\">!dh -s !D4C</code> コマンドを実行したところ、上記の通り <code class=\"language-text\">.rdata</code> セクションの <code class=\"language-text\">virtual address</code> が 0x3000 であり、アライメントされたサイズが 0x3600 であることがわかりました。</p>\n<p>つまり、このプロセスダンプの <code class=\"language-text\">.rdata</code> セクションは <code class=\"language-text\">!D4C+0x3000</code>(D4C.exe のイメージベースアドレスに 0x3000 を加算したアドレス) から 0x3600 バイト分の範囲に存在していると判断できます。</p>\n<p><code class=\"language-text\">.rdata</code> セクションのアドレス範囲を特定できたので、次は <code class=\"language-text\">s</code> コマンドを使用して指定のアドレス範囲からテキストを検索してみます。<sup id=\"fnref-16\"><a href=\"#fn-16\" class=\"footnote-ref\">16</a></sup></p>\n<p><code class=\"language-text\">s</code> コマンドを使用して指定のアドレス範囲から ASCII テキストを検索する場合、<code class=\"language-text\">s -a &lt;検索開始アドレス> L&lt;検索するサイズ> \"&lt;検索する ASCII テキスト>\"</code> を実行します。\n(<code class=\"language-text\">-a</code> オプションは、検索対象が ASCII 文字列であることを指定しています。Unicode 文字列を検索したい場合には <code class=\"language-text\">-u</code> オプションを使用します。)</p>\n<p>D4C.exe のプロセス内の <code class=\"language-text\">.rdata</code> セクションから <code class=\"language-text\">==> Allocated addr:</code> というテキストを検索する場合は、<code class=\"language-text\">s -a !D4C+0x3000 L0x3600 \"==> Allocated addr:\"</code> を実行します。</p>\n<p>実際にこのコマンドを実行してみたところ、以下のように 0x7ff6dfe236b0 のアドレスに該当の文字列が定義されていることを確認できました。</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">0:000> s -a !D4C+0x3000 L0x3600 \"==> Allocated addr:\" \n00007ff6`dfe236b0  3d 3d 3e 20 41 6c 6c 6f-63 61 74 65 64 20 61 64  ==> Allocated ad</code></pre></div>\n<p>上記の <code class=\"language-text\">s</code> コマンドの出力結果からは定義されているテキストの全文を参照できませんでしたので、<code class=\"language-text\">da</code> コマンドを使用して指定のアドレスに定義されているテキストを表示してみます。<sup id=\"fnref-17\"><a href=\"#fn-17\" class=\"footnote-ref\">17</a></sup></p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">0:000> da 00007ff6dfe236b0\n00007ff6`dfe236b0  \"==> Allocated addr: 0x%08x.\"</code></pre></div>\n<p>これで、上記の通り、0x7ff6dfe236b0 のアドレスに <code class=\"language-text\">==> Allocated addr: 0x%08x.</code> というテキストがハードコードされていることを確認できました。</p>\n<p>最後に、このテキストがハードコードされている相対仮想アドレス(RVA)を特定します。</p>\n<p>このテキストがハードコードされているアドレス 0x7ff6dfe236b0 から D4C.exe のイメージベースアドレスを引くことで、RVA を特定することが可能です。</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">0:000> ? 0x7ff6dfe236b0 - !D4C\nEvaluate expression: 14000 = 00000000`000036b0</code></pre></div>\n<p>上記コマンドでアドレスを計算した結果、対象のテキストが定義されている RVA は 0x36b0 であることを特定できました。</p>\n<p><code class=\"language-text\">==> Allocated addr:</code> という文字列がハードコードされているオフセットを特定できたので、続けて Ghidra デコンパイラを使用し、このテキストをヒープ領域に書き込む処理を特定します。</p>\n<p>4 章や 5 章と同じ手順で Ghidra を起動して D4C.exe をロードしたら、キーボードの [g] を押して GoTo ウインドウを起動します。</p>\n<p>続いて、D4C.exe を Ghidra にロードしたときの既定のイメージベースアドレス 0x140000000 に、先ほど確認したオフセット 0x36b0 を加算した値を入力し、[OK] をクリックします。</p>\n<p><span\n      class=\"gatsby-resp-image-wrapper\"\n      style=\"position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 500px; \"\n    >\n      <a\n    class=\"gatsby-resp-image-link\"\n    href=\"/static/231815079ca16cb22ceb06ce7dbd0ec7/0b533/app-leak-ghidra-001.png\"\n    style=\"display: block\"\n    target=\"_blank\"\n    rel=\"noopener\"\n  >\n    <span\n    class=\"gatsby-resp-image-background-image\"\n    style=\"padding-bottom: 32.916666666666664%; position: relative; bottom: 0; left: 0; background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAHCAYAAAAIy204AAAACXBIWXMAAA7EAAAOxAGVKw4bAAABT0lEQVQoz42R646cMAxGef+Xa6Vqq6HMDLvcZoAQEggQrmcN/V/V0lEcy/b3RQlSNZPpg8IcZNXKPZ+IspEwdYSZ45b23BLHsxwp7MZTdcSNk3zloazQ/a0pQ6IGglIP1AbeeuVZlOSVQ7uNV+tEyJI2hq9ak7UdVT9RuwnlPGbc5D5SXzWPkrzpPUHfDXDAsgxE8QeqqjBtgxEha6aLpu449o0zhsUxLiPHsdHPPW52DMJ5+kUWPh8Z0wTz7Pl1i/n5+84jfRHGRrD8+bT8uClpnvmfCKzpRe106IkeMWEYUdUKpRuSNOVLyMsK75drYBdnq7g9ZGjdVjbJT9Z9Zd93AudGaQZrJ4zRaNORlJqybijynLZtabUmfzc01lG6mt47Gd6wkxU6Ot9d5zCNBPcoYXBcDowxvOSHnm+hePEZx7LQiJi9nny6WMTVv+IbpBMXQh2xrMAAAAAASUVORK5CYII='); background-size: cover; display: block;\"\n  ></span>\n  <picture>\n          <source\n              srcset=\"/static/231815079ca16cb22ceb06ce7dbd0ec7/8ac56/app-leak-ghidra-001.webp 240w,\n/static/231815079ca16cb22ceb06ce7dbd0ec7/d3be9/app-leak-ghidra-001.webp 480w,\n/static/231815079ca16cb22ceb06ce7dbd0ec7/b0a15/app-leak-ghidra-001.webp 500w\"\n              sizes=\"(max-width: 500px) 100vw, 500px\"\n              type=\"image/webp\"\n            />\n          <source\n            srcset=\"/static/231815079ca16cb22ceb06ce7dbd0ec7/8ff5a/app-leak-ghidra-001.png 240w,\n/static/231815079ca16cb22ceb06ce7dbd0ec7/e85cb/app-leak-ghidra-001.png 480w,\n/static/231815079ca16cb22ceb06ce7dbd0ec7/0b533/app-leak-ghidra-001.png 500w\"\n            sizes=\"(max-width: 500px) 100vw, 500px\"\n            type=\"image/png\"\n          />\n          <img\n            class=\"gatsby-resp-image-image\"\n            src=\"/static/231815079ca16cb22ceb06ce7dbd0ec7/0b533/app-leak-ghidra-001.png\"\n            alt=\"Ghidra の GoTo ウインドウで指定のアドレスにジャンプする\"\n            title=\"Ghidra の GoTo ウインドウで指定のアドレスにジャンプする\"\n            loading=\"lazy\"\n            style=\"width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;\"\n          />\n        </picture>\n  </a>\n    </span></p>\n<p>これでアドレス 0x1400036b0 にジャンプし、<code class=\"language-text\">==> Allocated addr: 0x%08x.</code> というテキストがハードコードされていることを Ghidra 上でも確認することができました。</p>\n<p>なお、Ghidra の Listing ウインドウでアドレス 0x1400036b0 のテキストを参照してみると、右側に <code class=\"language-text\">XREF[1]: FUN_1400015a0:14000161d(*)</code> と表示されていることを確認できます。</p>\n<p>これは、このデータを参照しているコードのアドレスを指しています。</p>\n<p>Ghidra で <code class=\"language-text\">XREF[1]: FUN_1400015a0:14000161d(*)</code> の表示をダブルクリックしてみると、以下のように 0x1400036b0 のテキストをロードしているアドレス 0x14000161d にジャンプできます。</p>\n<p><span\n      class=\"gatsby-resp-image-wrapper\"\n      style=\"position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 500px; \"\n    >\n      <a\n    class=\"gatsby-resp-image-link\"\n    href=\"/static/586d87bba597b1dda0d225d755625bc6/0b533/app-leak-ghidra-002.png\"\n    style=\"display: block\"\n    target=\"_blank\"\n    rel=\"noopener\"\n  >\n    <span\n    class=\"gatsby-resp-image-background-image\"\n    style=\"padding-bottom: 62.5%; position: relative; bottom: 0; left: 0; background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAANCAYAAACpUE5eAAAACXBIWXMAAA7EAAAOxAGVKw4bAAACbUlEQVQ4y21Ta2/TQBDM//878KlfKvEFCUEFVaGlVG2a2Oe347N9D98jw5wdUZDYZJWzvJmdndnbXV094v27b7i+3uPmJsPDg8DzS4GuG1DXNeqmRdNU+H53j48fbvDl0y2+fr7Dj9tH/Lx7wq/7Zzw97LF/OSA7ZtiB0XcNTifALkAIHkNbYR419OxwPmONqm6wWB7Sc+DX8+iY/I1+e06xs0Q5vOYohIOUDtNk0BcD1GShZqZasCweWV6hbjt4PyOeA3H/82H3nXMOddWg7z3/HKD1gmk+wbmFneOF0hn54RVHITHPFcyiVjaJfQL5O3fLQoBpJlBksYNWDs5a+BA4foQhcAIXxz0ZDjhNLTTfx5DA4tbvr+DIFnkmLiN7ghrUZcUmlucFSjtY65Ad9uh6gU5JtHLEME7QbsLiDbwjAe0RXNgAq4L6VJ4gHpYAsiZjY8ks/OmcHw9kKDEqjZk1KZ1xNIN6xohz4MiRIytNhqJBXnh0J4dBWvTlQAYGkhKMzEl5CFGibwSqtkVWjcjLGkpOlMfRpE2/JOrOmDRygTz3OA00hmM2xxmy1QSbqKFHZOcsz1HmrOOKlTJHddqjHRpIMlaLhJbqbWTBwoIMx9Gvu9eXGnJgobLryqTRRVGiLCzKocIwN6xL7AycDjQovLm8akj6dU0NZw9Dl8dmhFWGzlsYjuS5PmVZYJxGKDOv7p+xgcR0jud/XS5pStMkwABLocuiheRNMYaM9QaYZCmp3TgPNG+iKYoGjmToVtBtLy8appGF8OvaaGpY86Y0HXWkQWnRUxwFGY50lbsXuISedy2uGTdDLoC/AaZ458RbcDXbAAAAAElFTkSuQmCC'); background-size: cover; display: block;\"\n  ></span>\n  <picture>\n          <source\n              srcset=\"/static/586d87bba597b1dda0d225d755625bc6/8ac56/app-leak-ghidra-002.webp 240w,\n/static/586d87bba597b1dda0d225d755625bc6/d3be9/app-leak-ghidra-002.webp 480w,\n/static/586d87bba597b1dda0d225d755625bc6/b0a15/app-leak-ghidra-002.webp 500w\"\n              sizes=\"(max-width: 500px) 100vw, 500px\"\n              type=\"image/webp\"\n            />\n          <source\n            srcset=\"/static/586d87bba597b1dda0d225d755625bc6/8ff5a/app-leak-ghidra-002.png 240w,\n/static/586d87bba597b1dda0d225d755625bc6/e85cb/app-leak-ghidra-002.png 480w,\n/static/586d87bba597b1dda0d225d755625bc6/0b533/app-leak-ghidra-002.png 500w\"\n            sizes=\"(max-width: 500px) 100vw, 500px\"\n            type=\"image/png\"\n          />\n          <img\n            class=\"gatsby-resp-image-image\"\n            src=\"/static/586d87bba597b1dda0d225d755625bc6/0b533/app-leak-ghidra-002.png\"\n            alt=\"ヒープへの書き込みを行う処理を特定する\"\n            title=\"ヒープへの書き込みを行う処理を特定する\"\n            loading=\"lazy\"\n            style=\"width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;\"\n          />\n        </picture>\n  </a>\n    </span></p>\n<p>このアドレスの前後の処理を Ghidra でデコンパイルした結果、以下のような疑似コードを得ることができました。</p>\n<div class=\"gatsby-highlight\" data-language=\"c\"><pre class=\"language-c\"><code class=\"language-c\"><span class=\"token keyword\">while</span><span class=\"token punctuation\">(</span> true <span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n   _Dst <span class=\"token operator\">=</span> <span class=\"token punctuation\">(</span><span class=\"token keyword\">char</span> <span class=\"token operator\">*</span><span class=\"token punctuation\">)</span><span class=\"token function\">malloc</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">(</span>longlong<span class=\"token punctuation\">)</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">int</span><span class=\"token punctuation\">)</span>param_1<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n   <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>_Dst <span class=\"token operator\">==</span> <span class=\"token punctuation\">(</span><span class=\"token keyword\">char</span> <span class=\"token operator\">*</span><span class=\"token punctuation\">)</span><span class=\"token number\">0x0</span><span class=\"token punctuation\">)</span> <span class=\"token keyword\">break</span><span class=\"token punctuation\">;</span>\n      <span class=\"token function\">printf</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"Count: %d\\n\"</span><span class=\"token punctuation\">,</span><span class=\"token punctuation\">(</span>ulonglong<span class=\"token punctuation\">)</span>uVar2<span class=\"token punctuation\">,</span>param_3<span class=\"token punctuation\">,</span>param_4<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\n   param_4 <span class=\"token operator\">=</span> <span class=\"token punctuation\">(</span>ulonglong<span class=\"token punctuation\">)</span>_Dst <span class=\"token operator\">&amp;</span> <span class=\"token number\">0xffffffff</span><span class=\"token punctuation\">;</span>\n   _SizeInBytes <span class=\"token operator\">=</span> <span class=\"token punctuation\">(</span>ulonglong<span class=\"token punctuation\">)</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">int</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">(</span>param_1 <span class=\"token operator\">-</span> <span class=\"token number\">1</span><span class=\"token punctuation\">)</span>\n\n   pcVar3 <span class=\"token operator\">=</span> <span class=\"token string\">\"==> Allocated addr: 0x%08x\\n\"</span><span class=\"token punctuation\">;</span>\n   <span class=\"token function\">FUN_140001540</span><span class=\"token punctuation\">(</span>local_1030<span class=\"token punctuation\">,</span>_SizeInBytes<span class=\"token punctuation\">,</span><span class=\"token string\">\"==> Allocated addr: 0x%08x\\n\"</span><span class=\"token punctuation\">,</span>param_4<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\n   <span class=\"token function\">printf</span><span class=\"token punctuation\">(</span><span class=\"token operator\">&amp;</span>DAT_1400036cc<span class=\"token punctuation\">,</span>local_1030<span class=\"token punctuation\">,</span>pcVar3<span class=\"token punctuation\">,</span>param_4<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n   <span class=\"token function\">printf</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"==> Total allocated size: 0x%08x\\n\"</span><span class=\"token punctuation\">,</span><span class=\"token punctuation\">(</span>ulonglong<span class=\"token punctuation\">)</span>uVar1<span class=\"token punctuation\">,</span>pcVar3<span class=\"token punctuation\">,</span>param_4<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\n   param_3 <span class=\"token operator\">=</span> local_1030<span class=\"token punctuation\">;</span>\n   <span class=\"token function\">strcpy_s</span><span class=\"token punctuation\">(</span>_Dst<span class=\"token punctuation\">,</span>_SizeInBytes<span class=\"token punctuation\">,</span>param_3<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\n   <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span><span class=\"token number\">0x1fffffff</span> <span class=\"token operator\">&lt;</span> <span class=\"token punctuation\">(</span><span class=\"token keyword\">int</span><span class=\"token punctuation\">)</span>uVar1<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n      <span class=\"token function\">printf</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"==> Slow Down...\\n\"</span><span class=\"token punctuation\">,</span>_SizeInBytes<span class=\"token punctuation\">,</span>param_3<span class=\"token punctuation\">,</span>param_4<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n      <span class=\"token function\">Sleep</span><span class=\"token punctuation\">(</span><span class=\"token number\">1000</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n   <span class=\"token punctuation\">}</span>\n\n   uVar2 <span class=\"token operator\">=</span> uVar2 <span class=\"token operator\">+</span> <span class=\"token number\">1</span><span class=\"token punctuation\">;</span>\n   uVar1 <span class=\"token operator\">=</span> uVar1 <span class=\"token operator\">+</span> param_1<span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span></code></pre></div>\n<p>この疑似コードを解析すると、while によるループ処理の中で malloc 関数によって確保されたヒープ領域に strcpy_s 関数で書き込みを行う処理を繰り返し行っているにも関わらず、確保したヒープを解放する処理が定義されていないことがわかります。</p>\n<p>これで、D4C.exe のユーザモードメモリリークが発生していた原因箇所を特定することができました。</p>\n<h2 id=\"6-章のまとめ\" style=\"position:relative;\"><a href=\"#6-%E7%AB%A0%E3%81%AE%E3%81%BE%E3%81%A8%E3%82%81\" aria-label=\"6 章のまとめ permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>6 章のまとめ</h2>\n<p>本章では、クラッシュを伴わない問題の原因をダンプファイルから調査する例として、ユーザモードアプリケーションのメモリリーク事象の解析を行いました。</p>\n<p>本書の最後の章となる 7 章では、本章で調査したものと同じメモリリーク事象をシステムのフルメモリダンプから調査していきます。</p>\n<p>一括りに「ダンプファイル」といっても、ユーザモードプロセスのダンプとシステムのフルメモリダンプでは解析手法や調査のアプローチが大きく変わります。</p>\n<p>4 章や 5 章で扱ったクラッシュダンプの解析と比較すると少々難解に思えるかもしれませんが、このような問題の調査はダンプファイル解析の醍醐味の一つかと思いますので、ぜひ最後まで楽しんでお読みいただければ幸いです。</p>\n<h2 id=\"各章へのリンク\" style=\"position:relative;\"><a href=\"#%E5%90%84%E7%AB%A0%E3%81%B8%E3%81%AE%E3%83%AA%E3%83%B3%E3%82%AF\" aria-label=\"各章へのリンク permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>各章へのリンク</h2>\n<ul>\n<li><a href=\"/magical-windbg-vol1-00\">まえがき</a></li>\n<li><a href=\"/magical-windbg-vol1-01\">1 章 環境構築</a></li>\n<li><a href=\"/magical-windbg-vol1-02\">2 章 WinDbg の基本操作</a></li>\n<li><a href=\"/magical-windbg-vol1-03\">3 章 解析に必要な前提知識</a></li>\n<li><a href=\"/magical-windbg-vol1-04\">4 章 アプリケーションのクラッシュダンプを解析する</a></li>\n<li><a href=\"/magical-windbg-vol1-05\">5 章 システムクラッシュ時のフルメモリダンプを解析する</a></li>\n<li><a href=\"/magical-windbg-vol1-06\">6 章 プロセスダンプからユーザモードアプリケーションのメモリリーク事象を調査する</a></li>\n<li><a href=\"/magical-windbg-vol1-07\">7 章 フルメモリダンプからユーザモードメモリリーク事象を調査する</a></li>\n<li><a href=\"/magical-windbg-vol1-50\">付録 A WinDbg の Tips</a></li>\n<li><a href=\"/magical-windbg-vol1-51\">付録 B Volatility 3 でクラッシュダンプを解析する</a></li>\n<li><a href=\"/magical-windbg-vol1-99\">あとがき</a></li>\n</ul>\n<div class=\"footnotes\">\n<hr>\n<ol>\n<li id=\"fn-1\">\n<p>仮想メモリと物理メモリ <a href=\"https://learn.microsoft.com/ja-jp/windows-hardware/drivers/debugger/virtual-and-physical-memory\" target=\"_blank\" rel=\"nofollow noopener noreferrer\">https://learn.microsoft.com/ja-jp/windows-hardware/drivers/debugger/virtual-and-physical-memory</a></p>\n<a href=\"#fnref-1\" class=\"footnote-backref\">↩</a>\n</li>\n<li id=\"fn-2\">\n<p>バグ チェック <code class=\"language-text\">0x8E:KERNEL_MODE_EXCEPTION_NOT_HANDLED</code> <a href=\"https://learn.microsoft.com/ja-jp/windows-hardware/drivers/debugger/bug-check-0x8e--kernel-mode-exception-not-handled\" target=\"_blank\" rel=\"nofollow noopener noreferrer\">https://learn.microsoft.com/ja-jp/windows-hardware/drivers/debugger/bug-check-0x8e—kernel-mode-exception-not-handled</a></p>\n<a href=\"#fnref-2\" class=\"footnote-backref\">↩</a>\n</li>\n<li id=\"fn-3\">\n<p>インサイド Windows 第 7 版 上 P.402 (Pavel Yosifovich, Alex Ionescu, Mark E. Russinovich, David A. Solomon 著 / 山内 和朗 訳 / 日系 BP 社 / 2018 年) </p>\n<a href=\"#fnref-3\" class=\"footnote-backref\">↩</a>\n</li>\n<li id=\"fn-4\">\n<p>HeapCreate 関数 <a href=\"https://learn.microsoft.com/ja-jp/windows/win32/api/heapapi/nf-heapapi-heapcreate\" target=\"_blank\" rel=\"nofollow noopener noreferrer\">https://learn.microsoft.com/ja-jp/windows/win32/api/heapapi/nf-heapapi-heapcreate</a></p>\n<a href=\"#fnref-4\" class=\"footnote-backref\">↩</a>\n</li>\n<li id=\"fn-5\">\n<p>HeapAlloc 関数 <a href=\"https://learn.microsoft.com/ja-jp/windows/win32/api/heapapi/nf-heapapi-heapalloc\" target=\"_blank\" rel=\"nofollow noopener noreferrer\">https://learn.microsoft.com/ja-jp/windows/win32/api/heapapi/nf-heapapi-heapalloc</a></p>\n<a href=\"#fnref-5\" class=\"footnote-backref\">↩</a>\n</li>\n<li id=\"fn-6\">\n<p>インサイド Windows 第 7 版 上 P.366 (Pavel Yosifovich, Alex Ionescu, Mark E. Russinovich, David A. Solomon 著 / 山内 和朗 訳 / 日系 BP 社 / 2018 年) </p>\n<a href=\"#fnref-6\" class=\"footnote-backref\">↩</a>\n</li>\n<li id=\"fn-7\">\n<p>!heap 拡張機能 <a href=\"https://learn.microsoft.com/ja-jp/windows-hardware/drivers/debugger/-heap\" target=\"_blank\" rel=\"nofollow noopener noreferrer\">https://learn.microsoft.com/ja-jp/windows-hardware/drivers/debugger/-heap</a></p>\n<a href=\"#fnref-7\" class=\"footnote-backref\">↩</a>\n</li>\n<li id=\"fn-8\">\n<p>インサイド Windows 第 7 版 上 P.368 (Pavel Yosifovich, Alex Ionescu, Mark E. Russinovich, David A. Solomon 著 / 山内 和朗 訳 / 日系 BP 社 / 2018 年)</p>\n<a href=\"#fnref-8\" class=\"footnote-backref\">↩</a>\n</li>\n<li id=\"fn-9\">\n<p>インサイド Windows 第 7 版 上 P.372 (Pavel Yosifovich, Alex Ionescu, Mark E. Russinovich, David A. Solomon 著 / 山内 和朗 訳 / 日系 BP 社 / 2018 年)</p>\n<a href=\"#fnref-9\" class=\"footnote-backref\">↩</a>\n</li>\n<li id=\"fn-10\">\n<p>Advanced Windows Debugging 1st Edition P.276 (Mario Hewardt, Daniel Pravat 著 / Addison-Wesley Professional / 2007 年)</p>\n<a href=\"#fnref-10\" class=\"footnote-backref\">↩</a>\n</li>\n<li id=\"fn-11\">\n<p>インサイド Windows 第 7 版 上 P.406 (Pavel Yosifovich, Alex Ionescu, Mark E. Russinovich, David A. Solomon 著 / 山内 和朗 訳 / 日系 BP 社 / 2018 年)</p>\n<a href=\"#fnref-11\" class=\"footnote-backref\">↩</a>\n</li>\n<li id=\"fn-12\">\n<p>Windows ダンプの極意 エラーが発生したら、まずダンプ解析！ P.120 (上原 祥市 著 / アスキーメディアワークス / 2008 年)</p>\n<a href=\"#fnref-12\" class=\"footnote-backref\">↩</a>\n</li>\n<li id=\"fn-13\">\n<p>!threads 拡張機能 <a href=\"https://learn.microsoft.com/ja-jp/windows-hardware/drivers/debugger/-thread\" target=\"_blank\" rel=\"nofollow noopener noreferrer\">https://learn.microsoft.com/ja-jp/windows-hardware/drivers/debugger/-thread</a></p>\n<a href=\"#fnref-13\" class=\"footnote-backref\">↩</a>\n</li>\n<li id=\"fn-14\">\n<p>!runaway 拡張機能 <a href=\"https://learn.microsoft.com/ja-jp/windows-hardware/drivers/debugger/-runaway\" target=\"_blank\" rel=\"nofollow noopener noreferrer\">https://learn.microsoft.com/ja-jp/windows-hardware/drivers/debugger/-runaway</a></p>\n<a href=\"#fnref-14\" class=\"footnote-backref\">↩</a>\n</li>\n<li id=\"fn-15\">\n<p>PE 形式 <a href=\"https://learn.microsoft.com/ja-jp/windows/win32/debug/pe-format\" target=\"_blank\" rel=\"nofollow noopener noreferrer\">https://learn.microsoft.com/ja-jp/windows/win32/debug/pe-format</a></p>\n<a href=\"#fnref-15\" class=\"footnote-backref\">↩</a>\n</li>\n<li id=\"fn-16\">\n<p>s メモリの検索 <a href=\"https://learn.microsoft.com/ja-jp/windows-hardware/drivers/debugger/s--search-memory-\" target=\"_blank\" rel=\"nofollow noopener noreferrer\">https://learn.microsoft.com/ja-jp/windows-hardware/drivers/debugger/s—search-memory-</a></p>\n<a href=\"#fnref-16\" class=\"footnote-backref\">↩</a>\n</li>\n<li id=\"fn-17\">\n<p>d、da、db、dc、dd、dD、df、dp、dq、du、dw ディスプレイメモリ <a href=\"https://learn.microsoft.com/ja-jp/windows-hardware/drivers/debugger/d--da--db--dc--dd--dd--df--dp--dq--du--dw--dw--dyb--dyd--display-memor\" target=\"_blank\" rel=\"nofollow noopener noreferrer\">https://learn.microsoft.com/ja-jp/windows-hardware/drivers/debugger/d—da—db—dc—dd—dd—df—dp—dq—du—dw—dw—dyb—dyd—display-memor</a></p>\n<a href=\"#fnref-17\" class=\"footnote-backref\">↩</a>\n</li>\n</ol>\n</div>","fields":{"slug":"/magical-windbg-vol1-06","tagSlugs":["/tag/magical-win-dbg/","/tag/windows/","/tag/win-dbg/"]},"frontmatter":{"date":"2023-11-15","description":"技術書典 15 で頒布した Magical WinDbg -雰囲気で楽しむ Windows ダンプ解析とトラブルシューティング- VOL.1 の WEB 版です。","tags":["Magical WinDbg","Windows","WinDbg"],"title":"Magical WinDbg VOL.1【6 章 プロセスダンプからユーザモードアプリケーションのメモリリーク事象を調査する】","socialImage":{"publicURL":"/static/2dbf3e09d59db889dc9dc41adcc8e827/magical-windbg-vol1.png"}}}},"pageContext":{"slug":"/magical-windbg-vol1-06"}},"staticQueryHashes":["251939775","401334301","825871152"]}