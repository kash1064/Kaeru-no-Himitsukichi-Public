{"componentChunkName":"component---src-templates-post-template-js","path":"/python-syntax-in","result":{"data":{"markdownRemark":{"id":"6d028ef8-a1b4-5039-b1b1-1b25305b9200","html":"<p>今回は、「Pythonの辞書にKeyが存在するか確かめる in と、配列探索の in が全く違って驚いた」話について書きます。</p>\n<p>競技プログラミングなどをやっていると、各メソッドの計算量が気になると思います。</p>\n<p>例えばPythonを使う場合、リストの中に値が存在するかを確認するための<code class=\"language-text\">Value in List</code>という構文の計算量はO(N)であるために、非常に時間がかかることはご存知のとおりかと思います。</p>\n<p>手元の環境では、次のようなコードの実行時間は600ms程度でした。</p>\n<div class=\"gatsby-highlight\" data-language=\"python\"><pre class=\"language-python\"><code class=\"language-python\">Arr <span class=\"token operator\">=</span> <span class=\"token punctuation\">[</span>i <span class=\"token keyword\">for</span> i <span class=\"token keyword\">in</span> <span class=\"token builtin\">range</span><span class=\"token punctuation\">(</span><span class=\"token builtin\">pow</span><span class=\"token punctuation\">(</span><span class=\"token number\">10</span><span class=\"token punctuation\">,</span> <span class=\"token number\">7</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">]</span>\n<span class=\"token keyword\">print</span><span class=\"token punctuation\">(</span><span class=\"token builtin\">pow</span><span class=\"token punctuation\">(</span><span class=\"token number\">10</span><span class=\"token punctuation\">,</span> <span class=\"token number\">5</span><span class=\"token punctuation\">)</span> <span class=\"token keyword\">in</span> Arr<span class=\"token punctuation\">)</span></code></pre></div>\n<p>これは、リスト内包表現で定義した要素数が10^7個の配列Arrに対して、ある値が存在するか否かを一つ一つ確かめる実装になっているためです。</p>\n<p>一方で、Pythonの辞書型にも<code class=\"language-text\">Key in Dict</code>という、辞書にキーが存在するかどうかを確認するための記法が存在します。</p>\n<p>恥ずかしながら、僕はこの計算量も同じくO(N)で時間がかかるので、キーの存在確認のためには、<code class=\"language-text\">Dict.get(Key)</code>のように、getメソッドを用いた方がいいとずっと思いこんできました。</p>\n<p>しかし、Pythonの辞書にKeyが存在するか確かめる in と、配列探索の in は全く異なる実装であり、何なら<code class=\"language-text\">Dict.get(Key)</code>より<code class=\"language-text\">Key in Dict</code>の方が高速に動作するというのを初めて知ったので、こうして記事にまとめることにしました。</p>\n<!-- omit in toc -->\n<h2 id=\"もくじ\" style=\"position:relative;\"><a href=\"#%E3%82%82%E3%81%8F%E3%81%98\" aria-label=\"もくじ permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>もくじ</h2>\n<ul>\n<li><a href=\"#key-in-dict-%E3%81%AE%E5%AE%9F%E8%A3%85%E3%81%AB%E3%81%A4%E3%81%84%E3%81%A6\">Key in Dict の実装について</a></li>\n<li><a href=\"#%E3%81%8A%E3%81%BE%E3%81%91value-in-list%E3%81%AE%E5%AE%9F%E8%A3%85%E3%81%AB%E3%81%A4%E3%81%84%E3%81%A6\">おまけ：Value in Listの実装について</a></li>\n<li><a href=\"#%E3%81%BE%E3%81%A8%E3%82%81\">まとめ</a></li>\n</ul>\n<h2 id=\"key-in-dict-の実装について\" style=\"position:relative;\"><a href=\"#key-in-dict-%E3%81%AE%E5%AE%9F%E8%A3%85%E3%81%AB%E3%81%A4%E3%81%84%E3%81%A6\" aria-label=\"key in dict の実装について permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Key in Dict の実装について</h2>\n<p>まずは、<code class=\"language-text\">Key in Dict</code>の記法で呼び出される関数PyDict_Contains()について見ていきます。</p>\n<div class=\"gatsby-highlight\" data-language=\"python\"><pre class=\"language-python\"><code class=\"language-python\"><span class=\"token operator\">/</span><span class=\"token operator\">*</span> Return <span class=\"token number\">1</span> <span class=\"token keyword\">if</span> `key` <span class=\"token keyword\">is</span> <span class=\"token keyword\">in</span> <span class=\"token builtin\">dict</span> `op`<span class=\"token punctuation\">,</span> <span class=\"token number\">0</span> <span class=\"token keyword\">if</span> <span class=\"token keyword\">not</span><span class=\"token punctuation\">,</span> <span class=\"token keyword\">and</span> <span class=\"token operator\">-</span><span class=\"token number\">1</span> on error<span class=\"token punctuation\">.</span> <span class=\"token operator\">*</span><span class=\"token operator\">/</span>\n<span class=\"token builtin\">int</span>\nPyDict_Contains<span class=\"token punctuation\">(</span>PyObject <span class=\"token operator\">*</span>op<span class=\"token punctuation\">,</span> PyObject <span class=\"token operator\">*</span>key<span class=\"token punctuation\">)</span>\n<span class=\"token punctuation\">{</span>\n    Py_hash_t <span class=\"token builtin\">hash</span><span class=\"token punctuation\">;</span>\n    Py_ssize_t ix<span class=\"token punctuation\">;</span>\n    PyDictObject <span class=\"token operator\">*</span>mp <span class=\"token operator\">=</span> <span class=\"token punctuation\">(</span>PyDictObject <span class=\"token operator\">*</span><span class=\"token punctuation\">)</span>op<span class=\"token punctuation\">;</span>\n    PyObject <span class=\"token operator\">*</span>value<span class=\"token punctuation\">;</span>\n\n    <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>!PyUnicode_CheckExact<span class=\"token punctuation\">(</span>key<span class=\"token punctuation\">)</span> <span class=\"token operator\">|</span><span class=\"token operator\">|</span>\n        <span class=\"token punctuation\">(</span><span class=\"token builtin\">hash</span> <span class=\"token operator\">=</span> <span class=\"token punctuation\">(</span><span class=\"token punctuation\">(</span>PyASCIIObject <span class=\"token operator\">*</span><span class=\"token punctuation\">)</span> key<span class=\"token punctuation\">)</span><span class=\"token operator\">-</span><span class=\"token operator\">></span><span class=\"token builtin\">hash</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">==</span> <span class=\"token operator\">-</span><span class=\"token number\">1</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n        <span class=\"token builtin\">hash</span> <span class=\"token operator\">=</span> PyObject_Hash<span class=\"token punctuation\">(</span>key<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n        <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span><span class=\"token builtin\">hash</span> <span class=\"token operator\">==</span> <span class=\"token operator\">-</span><span class=\"token number\">1</span><span class=\"token punctuation\">)</span>\n            <span class=\"token keyword\">return</span> <span class=\"token operator\">-</span><span class=\"token number\">1</span><span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">}</span>\n    ix <span class=\"token operator\">=</span> _Py_dict_lookup<span class=\"token punctuation\">(</span>mp<span class=\"token punctuation\">,</span> key<span class=\"token punctuation\">,</span> <span class=\"token builtin\">hash</span><span class=\"token punctuation\">,</span> <span class=\"token operator\">&amp;</span>value<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>ix <span class=\"token operator\">==</span> DKIX_ERROR<span class=\"token punctuation\">)</span>\n        <span class=\"token keyword\">return</span> <span class=\"token operator\">-</span><span class=\"token number\">1</span><span class=\"token punctuation\">;</span>\n    <span class=\"token keyword\">return</span> <span class=\"token punctuation\">(</span>ix <span class=\"token operator\">!=</span> DKIX_EMPTY <span class=\"token operator\">&amp;</span><span class=\"token operator\">&amp;</span> value <span class=\"token operator\">!=</span> NULL<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span></code></pre></div>\n<p>参考：<a href=\"https://github.com/python/cpython/blob/818628c2da99ba0376313971816d472c65c9a9fc/Objects/dictobject.c\" target=\"_blank\" rel=\"nofollow noopener noreferrer\">cpython/dictobject.c   python/cpython · GitHub</a></p>\n<p>Pythonの場合は、すべてのオブジェクトは、<code class=\"language-text\">PyObject</code>‘型のポインターを介してアクセスされる仕様になっています。\nここで引数として与えられている<code class=\"language-text\">PyObject *op</code>は、検索対象の辞書オブジェクトを指している認識です。</p>\n<p>さて、PyDict<em>Contains関数の処理を見ると、まずハッシュを計算し、そのハッシュを引数とした</em>Py<em>dict</em>lookup関数にて、キーが辞書に存在するかの判定を行っています。\n※ <em>Py</em>dict_lookup()の処理についてはここでは割愛します。</p>\n<p>つまり、リスト型の<code class=\"language-text\">Value in List</code>の構文と異なり、O(N)ではなくO(logN)の対数時間でキーの存在確認を行うことができるというわけです。</p>\n<p>では、これまで僕がつかっていた<code class=\"language-text\">Dict.get(Key)</code>の構文はどのような処理を行っているのか確認してみます。</p>\n<div class=\"gatsby-highlight\" data-language=\"python\"><pre class=\"language-python\"><code class=\"language-python\">static PyObject <span class=\"token operator\">*</span>\ndict_get_impl<span class=\"token punctuation\">(</span>PyDictObject <span class=\"token operator\">*</span>self<span class=\"token punctuation\">,</span> PyObject <span class=\"token operator\">*</span>key<span class=\"token punctuation\">,</span> PyObject <span class=\"token operator\">*</span>default_value<span class=\"token punctuation\">)</span>\n<span class=\"token operator\">/</span><span class=\"token operator\">*</span><span class=\"token punctuation\">[</span>clinic end generated code<span class=\"token punctuation\">:</span> output<span class=\"token operator\">=</span>bba707729dee05bf <span class=\"token builtin\">input</span><span class=\"token operator\">=</span>279ddb5790b6b107<span class=\"token punctuation\">]</span><span class=\"token operator\">*</span><span class=\"token operator\">/</span>\n<span class=\"token punctuation\">{</span>\n    PyObject <span class=\"token operator\">*</span>val <span class=\"token operator\">=</span> NULL<span class=\"token punctuation\">;</span>\n    Py_hash_t <span class=\"token builtin\">hash</span><span class=\"token punctuation\">;</span>\n    Py_ssize_t ix<span class=\"token punctuation\">;</span>\n\n    <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>!PyUnicode_CheckExact<span class=\"token punctuation\">(</span>key<span class=\"token punctuation\">)</span> <span class=\"token operator\">|</span><span class=\"token operator\">|</span>\n        <span class=\"token punctuation\">(</span><span class=\"token builtin\">hash</span> <span class=\"token operator\">=</span> <span class=\"token punctuation\">(</span><span class=\"token punctuation\">(</span>PyASCIIObject <span class=\"token operator\">*</span><span class=\"token punctuation\">)</span> key<span class=\"token punctuation\">)</span><span class=\"token operator\">-</span><span class=\"token operator\">></span><span class=\"token builtin\">hash</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">==</span> <span class=\"token operator\">-</span><span class=\"token number\">1</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n        <span class=\"token builtin\">hash</span> <span class=\"token operator\">=</span> PyObject_Hash<span class=\"token punctuation\">(</span>key<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n        <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span><span class=\"token builtin\">hash</span> <span class=\"token operator\">==</span> <span class=\"token operator\">-</span><span class=\"token number\">1</span><span class=\"token punctuation\">)</span>\n            <span class=\"token keyword\">return</span> NULL<span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">}</span>\n    ix <span class=\"token operator\">=</span> _Py_dict_lookup<span class=\"token punctuation\">(</span>self<span class=\"token punctuation\">,</span> key<span class=\"token punctuation\">,</span> <span class=\"token builtin\">hash</span><span class=\"token punctuation\">,</span> <span class=\"token operator\">&amp;</span>val<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>ix <span class=\"token operator\">==</span> DKIX_ERROR<span class=\"token punctuation\">)</span>\n        <span class=\"token keyword\">return</span> NULL<span class=\"token punctuation\">;</span>\n    <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>ix <span class=\"token operator\">==</span> DKIX_EMPTY <span class=\"token operator\">|</span><span class=\"token operator\">|</span> val <span class=\"token operator\">==</span> NULL<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n        val <span class=\"token operator\">=</span> default_value<span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">}</span>\n    Py_INCREF<span class=\"token punctuation\">(</span>val<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token keyword\">return</span> val<span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span></code></pre></div>\n<p>参考：<a href=\"https://github.com/python/cpython/blob/818628c2da99ba0376313971816d472c65c9a9fc/Objects/dictobject.c\" target=\"_blank\" rel=\"nofollow noopener noreferrer\">cpython/dictobject.c   python/cpython · GitHub</a></p>\n<p>なんと、<code class=\"language-text\">Key in Dict</code>の構文を使用した場合に呼び出されるPyDict_Contains関数と、ほとんど実装に差がないことがわかります。</p>\n<p>Diffを取ってみると、主な実装の部分にはほとんど差異がないことがわかります。</p>\n<p><span\n      class=\"gatsby-resp-image-wrapper\"\n      style=\"position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 960px; \"\n    >\n      <a\n    class=\"gatsby-resp-image-link\"\n    href=\"/static/c41bc80e8b3439629fee212ac4cccbad/2bef9/image-1024x416.png\"\n    style=\"display: block\"\n    target=\"_blank\"\n    rel=\"noopener\"\n  >\n    <span\n    class=\"gatsby-resp-image-background-image\"\n    style=\"padding-bottom: 40.833333333333336%; position: relative; bottom: 0; left: 0; background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAICAYAAAD5nd/tAAAACXBIWXMAARlAAAEZQAGA43XUAAABmElEQVQoz2WS3XKbMBSEeYs0Yw8IkAGB+DPin9iO7TgJidNepJ1c9P1fY7v2NJ3J9OLjIOmwZxewZt/HRxji3fPwncyuizchcLZtzIslnl2Bvk9xOneYf4y4f6xJhd2DwfZYYXOouDY4zg2aMYEVUmCdJKi1RhIEiKVEvFoh4r6kqJI+iirG9mBwmifWGt2dJukXhk2GeohhjcslfsYxPrIMZ8fBK0UuPN9+w3xzgyeeB3QuOURFCq7rwWGfEO4V9y+CqVyasFa8aDZ3ZYnRGPSs2cUpRQIKh2xe0bXHdVEUMOy5oJSC9OVVxLYdYl+xSm4UjsDEyBOdVnww40FO9GKBnJPzXEFpibotMUwGxTqGSuSVUHnE/Yd1R/sPdPBKwZc0xYH3e8/HPQd1jDzyvK411k2CaVvjcBrQDCmqVqM0CjqXX7A0nbSM2EcRan7thrR8BRUp6dZEATb7EseXCu+/d3j7NWH3VGDaa/S7GP1Wkc+qYAnfg6Arm44cCnwi+DtdqgwDZGUM0yVox4zRPUSJx7hE+//xB/5r9Exiezr9AAAAAElFTkSuQmCC'); background-size: cover; display: block;\"\n  ></span>\n  <picture>\n          <source\n              srcset=\"/static/c41bc80e8b3439629fee212ac4cccbad/8ac56/image-1024x416.webp 240w,\n/static/c41bc80e8b3439629fee212ac4cccbad/d3be9/image-1024x416.webp 480w,\n/static/c41bc80e8b3439629fee212ac4cccbad/e46b2/image-1024x416.webp 960w,\n/static/c41bc80e8b3439629fee212ac4cccbad/a9a89/image-1024x416.webp 1024w\"\n              sizes=\"(max-width: 960px) 100vw, 960px\"\n              type=\"image/webp\"\n            />\n          <source\n            srcset=\"/static/c41bc80e8b3439629fee212ac4cccbad/8ff5a/image-1024x416.png 240w,\n/static/c41bc80e8b3439629fee212ac4cccbad/e85cb/image-1024x416.png 480w,\n/static/c41bc80e8b3439629fee212ac4cccbad/d9199/image-1024x416.png 960w,\n/static/c41bc80e8b3439629fee212ac4cccbad/2bef9/image-1024x416.png 1024w\"\n            sizes=\"(max-width: 960px) 100vw, 960px\"\n            type=\"image/png\"\n          />\n          <img\n            class=\"gatsby-resp-image-image\"\n            src=\"/static/c41bc80e8b3439629fee212ac4cccbad/d9199/image-1024x416.png\"\n            alt=\"image\"\n            title=\"image\"\n            loading=\"lazy\"\n            style=\"width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;\"\n          />\n        </picture>\n  </a>\n    </span></p>\n<p>また、驚いた点としては、<code class=\"language-text\">Dict.get(Key)</code>の構文で呼び出されるdict<em>get</em>impl関数の方が、Py_INCREF()というマクロの処理を呼び出しているために、ごくわずかに実行時間が長くなることがわかります。</p>\n<p>参考：<a href=\"https://docs.python.org/ja/3/c-api/refcounting.html\" target=\"_blank\" rel=\"nofollow noopener noreferrer\">参照カウント — Python 3.9.4 ドキュメント</a></p>\n<p>実際にPythonの辞書型を使用する競技プログラミングの問題を、<code class=\"language-text\">Key in Dict</code>の構文と<code class=\"language-text\">Dict.get(Key)</code>の構文のそれぞれで実装してみたところ、<code class=\"language-text\">Key in Dict</code>の構文の方が実行時間が数ミリ秒短くなることが確認できました。</p>\n<h2 id=\"おまけvalue-in-listの実装について\" style=\"position:relative;\"><a href=\"#%E3%81%8A%E3%81%BE%E3%81%91value-in-list%E3%81%AE%E5%AE%9F%E8%A3%85%E3%81%AB%E3%81%A4%E3%81%84%E3%81%A6\" aria-label=\"おまけvalue in listの実装について permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>おまけ：Value in Listの実装について</h2>\n<p>リストの中に値が存在するかを確認するための<code class=\"language-text\">Value in List</code>という構文についても、ついでなので中身を見てみました。</p>\n<p>見たまんまではありますが、for文でリストオブジェクトの先頭アドレスから値を比較していくという、O(N)の処理になっています。</p>\n<div class=\"gatsby-highlight\" data-language=\"python\"><pre class=\"language-python\"><code class=\"language-python\">static <span class=\"token builtin\">int</span>\nlist_contains<span class=\"token punctuation\">(</span>PyListObject <span class=\"token operator\">*</span>a<span class=\"token punctuation\">,</span> PyObject <span class=\"token operator\">*</span>el<span class=\"token punctuation\">)</span>\n<span class=\"token punctuation\">{</span>\n    PyObject <span class=\"token operator\">*</span>item<span class=\"token punctuation\">;</span>\n    Py_ssize_t i<span class=\"token punctuation\">;</span>\n    <span class=\"token builtin\">int</span> <span class=\"token builtin\">cmp</span><span class=\"token punctuation\">;</span>\n\n    <span class=\"token keyword\">for</span> <span class=\"token punctuation\">(</span>i <span class=\"token operator\">=</span> <span class=\"token number\">0</span><span class=\"token punctuation\">,</span> <span class=\"token builtin\">cmp</span> <span class=\"token operator\">=</span> <span class=\"token number\">0</span> <span class=\"token punctuation\">;</span> <span class=\"token builtin\">cmp</span> <span class=\"token operator\">==</span> <span class=\"token number\">0</span> <span class=\"token operator\">&amp;</span><span class=\"token operator\">&amp;</span> i <span class=\"token operator\">&lt;</span> Py_SIZE<span class=\"token punctuation\">(</span>a<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span> <span class=\"token operator\">+</span><span class=\"token operator\">+</span>i<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n        item <span class=\"token operator\">=</span> PyList_GET_ITEM<span class=\"token punctuation\">(</span>a<span class=\"token punctuation\">,</span> i<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n        Py_INCREF<span class=\"token punctuation\">(</span>item<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n        <span class=\"token builtin\">cmp</span> <span class=\"token operator\">=</span> PyObject_RichCompareBool<span class=\"token punctuation\">(</span>item<span class=\"token punctuation\">,</span> el<span class=\"token punctuation\">,</span> Py_EQ<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n        Py_DECREF<span class=\"token punctuation\">(</span>item<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">}</span>\n    <span class=\"token keyword\">return</span> <span class=\"token builtin\">cmp</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span></code></pre></div>\n<p>参考：<a href=\"https://github.com/python/cpython/blob/818628c2da99ba0376313971816d472c65c9a9fc/Objects/listobject.c\" target=\"_blank\" rel=\"nofollow noopener noreferrer\">cpython/listobject.c  python/cpython · GitHub</a></p>\n<h2 id=\"まとめ\" style=\"position:relative;\"><a href=\"#%E3%81%BE%E3%81%A8%E3%82%81\" aria-label=\"まとめ permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>まとめ</h2>\n<p>競プロの問題を解いているときに、「せっかく連想配列使ってるのにKeyの探索を in で実装したらTLEになるのでは？？」という疑問からCPythonのソースコードを掘り下げるまでに至りました。</p>\n<p>真面目に調べたので備忘録として記事にしてみましたが、CPythonのソースを追ってみたことで言語仕様への理解も深まったので、今後も似たようなことをやっていけたらと考えています。</p>\n<p>ちなみに計算量だけを知りたい場合は、<a href=\"https://wiki.python.org/moin/TimeComplexity\" target=\"_blank\" rel=\"nofollow noopener noreferrer\">TimeComplexity - Python Wiki</a>が便利です。</p>","fields":{"slug":"/python-syntax-in","tagSlugs":["/tag/python/"]},"frontmatter":{"date":"2021-07-23","description":"「Pythonの辞書にKeyが存在するか確かめる in と、配列探索の in が全く違って驚いた」話について書きます。","tags":["Python"],"title":"Pythonの辞書にKeyが存在するか確かめる in と、配列探索の in が全く違った話","socialImage":{"publicURL":"/static/dc4d8b7f8795f3c3d3489d9957d155f2/no-image.png"}}}},"pageContext":{"slug":"/python-syntax-in"}},"staticQueryHashes":["251939775","401334301","825871152"]}