<!DOCTYPE html><html lang="ja"><head><meta charSet="utf-8"/><meta http-equiv="x-ua-compatible" content="ie=edge"/><meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no"/><style data-href="/styles.e71379dda153709d1a9a.css" id="gatsby-global-css">html{font-size:100}body{margin:0 0 0 calc(100vw - 100%);color:#222;line-height:1.4;font-size:.875rem;-ms-text-size-adjust:100%;-webkit-text-size-adjust:100%;text-rendering:optimizeLegibility;-webkit-font-smoothing:antialiased;-moz-osx-font-smoothing:grayscale;background-color:#fcfcfc}body,h1,h2,h3,h4,h5,h6{font-family:-apple-system,BlinkMacSystemFont,Segoe UI,Roboto,Oxygen-Sans,Ubuntu,Cantarell,Helvetica Neue,sans-serif}h1,h2,h3,h4,h5,h6{font-weight:600}h1{font-size:1.575rem;line-height:2.25rem;margin-top:5rem;margin-bottom:1.25rem}h2{font-size:1.47656rem;line-height:1.875rem}h2,h3{margin-top:2.5rem;margin-bottom:.625rem}h3{font-size:1.20313rem;line-height:1.25rem}h4{font-size:1.05rem;margin-top:1.875rem}h4,h5{line-height:1.25rem;margin-bottom:.625rem}h5,h6{font-size:.875rem;margin-top:3.125rem}h6{line-height:1.25rem;margin-bottom:.625rem}img{max-width:100%;margin:inherit auto}hr,img{border:0;display:block}hr{color:#222;height:1.625rem;margin:3.25rem auto;background-size:100% 26px;background-image:linear-gradient(180deg,transparent 1px,transparent 11px,#222 0,#222 15px,transparent 0,transparent 26px);width:6.25rem}a{color:#918d40;text-decoration:none}a:active,a:focus,a:hover{color:#a9d159}b,strong{font-weight:600}ul{list-style:square;margin-bottom:1.25rem}ul li{padding:0 .3125rem;margin-bottom:.625rem}p{line-height:1.25rem;margin-bottom:1.25rem}blockquote{font-style:italic;text-align:center;background-color:#f5f5f5;padding:.1875rem .625rem}figure{display:block;width:100%;height:auto}figcaption{line-height:.9375rem;margin-top:.3125rem;color:#222;font-size:.75rem;font-style:italic;margin-bottom:0;text-align:center}.anchor{margin-left:-1.875rem!important;padding-right:.875rem!important}@media screen and (min-width:685px){figure.float-left,figure.float-right{max-width:19.375rem;padding:0 1.25rem}.float-right{float:right}.float-left{float:left}}code[class*=language-],pre[class*=language-]{color:#ccc;background:0 0;font-family:Consolas,Monaco,Andale Mono,Ubuntu Mono,monospace;font-size:1em;text-align:left;white-space:pre;word-spacing:normal;word-break:normal;word-wrap:normal;line-height:1.5;-o-tab-size:4;tab-size:4;-webkit-hyphens:none;-ms-hyphens:none;hyphens:none}pre[class*=language-]{padding:1em;margin:.5em 0;overflow:auto}:not(pre)>code[class*=language-],pre[class*=language-]{background:#2d2d2d}:not(pre)>code[class*=language-]{padding:.1em;border-radius:.3em;white-space:normal}.token.block-comment,.token.cdata,.token.comment,.token.doctype,.token.prolog{color:#999}.token.punctuation{color:#ccc}.token.attr-name,.token.deleted,.token.namespace,.token.tag{color:#e2777a}.token.function-name{color:#6196cc}.token.boolean,.token.function,.token.number{color:#f08d49}.token.class-name,.token.constant,.token.property,.token.symbol{color:#f8c555}.token.atrule,.token.builtin,.token.important,.token.keyword,.token.selector{color:#cc99cd}.token.attr-value,.token.char,.token.regex,.token.string,.token.variable{color:#7ec699}.token.entity,.token.operator,.token.url{color:#67cdcc}.token.bold,.token.important{font-weight:700}.token.italic{font-style:italic}.token.entity{cursor:help}.token.inserted{color:green}li>code[class*=language-text],p>code[class*=language-text]{background:#f9f9f9!important;color:#2d2d2d!important}.Author-module--author__photo--36xCH{display:inline-block;margin-bottom:0;border-radius:50%;background-clip:padding-box}.Author-module--author__title--2CaTb{font-size:.98438rem;font-weight:600;line-height:1.40625rem;margin:.625rem 0}.Author-module--author__title-link--Yrism,.Author-module--author__title-link--Yrism:focus,.Author-module--author__title-link--Yrism:hover{color:#222}.Author-module--author__subtitle--cAaEB{color:#888;line-height:1.25rem;margin-bottom:1.25rem}.Icon-module--icon--Gpyvw{display:inline-block;width:1em;height:1em;stroke-width:0;stroke:currentColor;fill:currentColor;font-style:normal;font-weight:400;speak:none;margin-right:.2em;text-align:center;font-variant:normal;text-transform:none;line-height:1em;margin-left:.2em;-webkit-font-smoothing:antialiased;-moz-osx-font-smoothing:grayscale}.Contacts-module--contacts--1rGd1{margin-bottom:1.25rem}.Contacts-module--contacts__list--3OgdW{display:flex;flex-flow:row wrap;flex-grow:0;flex-shrink:0;list-style:none;padding:0;margin:.625rem -.1875rem;width:8.75rem}.Contacts-module--contacts__list-item--16p9q{padding:0;margin:.25rem;display:flex;align-content:center;align-items:center;justify-content:center;height:2.1875rem;width:2.1875rem;line-height:2.1875rem;border-radius:50%;text-align:center;border:1px solid #ebebeb}.Contacts-module--contacts__list-item-link--2MIDn{border:0;display:flex;color:#222}.Contacts-module--contacts__list-item-link--2MIDn:focus,.Contacts-module--contacts__list-item-link--2MIDn:hover{color:#918d40}.Copyright-module--copyright--1ariN{color:#b6b6b6;font-size:.75rem}.Menu-module--menu--Efbin{margin-bottom:1.25rem}.Menu-module--menu__list--31Zeo{list-style:none;padding:0;margin:0}.Menu-module--menu__list-item--1lJ6B{padding:0;margin:.625rem 0}.Menu-module--menu__list-item-link--10Ush{font-size:.875rem;color:#222;font-weight:400;border:0}.Menu-module--menu__list-item-link--10Ush:focus,.Menu-module--menu__list-item-link--10Ush:hover{color:#918d40;border-bottom:1px solid #918d40}.Menu-module--menu__list-item-link--active--2CbUO{color:#222;border-bottom:1px solid #222}.Sidebar-module--sidebar--X4z2p{width:100%}.Sidebar-module--sidebar__inner--Jdc5s{position:relative;padding:1.5625rem 1.25rem 0}.Sidebar-module--headerimage--19Rdy{width:100%;min-height:70px;max-height:120px;margin:0 0 .625rem}.Sidebar-module--logo-image--XDYae{min-height:70px;max-height:120px;margin:0 auto}input{-webkit-appearance:none;-moz-appearance:none;appearance:none;padding:.625rem;margin:.3125rem 0;border:1px solid #999;border-radius:.3125rem}.Sidebar-module--search-container--17C6F{position:relative}.Sidebar-module--search-container-input--27Tw4{width:100%}.Sidebar-module--search-container-submit--WwtLg{position:absolute;width:2.375rem;height:2.375rem;top:calc(50% - 19px);right:0;border:3px solid #999;border-radius:0 .25rem .25rem 0;background:#999}.Sidebar-module--search-container-submit--WwtLg:before{position:absolute;content:"";width:.9375rem;height:.9375rem;top:calc(50% - 9px);left:calc(50% - 9px);border-radius:50%;box-shadow:0 0 0 2px #fff}.Sidebar-module--search-container-submit--WwtLg:after{position:absolute;content:"";width:.5rem;height:.375rem;top:calc(50% + 6px);left:calc(50% + 2px);border-top:2px solid #fff;transform:rotate(45deg)}@media screen and (min-width:685px){.Sidebar-module--sidebar--X4z2p{width:calc(41.625% - 1.09375rem)}.Sidebar-module--sidebar--X4z2p:nth-child(1n){float:left;margin-right:1.875rem;clear:none}.Sidebar-module--sidebar--X4z2p:last-child{margin-right:0}.Sidebar-module--sidebar--X4z2p:nth-child(12n){margin-right:0;float:right}.Sidebar-module--sidebar--X4z2p:nth-child(12n+1){clear:both}.Sidebar-module--sidebar__inner--Jdc5s{padding:1.875rem 1.25rem 0}.Sidebar-module--sidebar__inner--Jdc5s:after{background:#e6e6e6;background:linear-gradient(180deg,#e6e6e6 0,#e6e6e6 48%,#fff);position:absolute;content:"";width:.0625rem;height:33.75rem;top:30px;right:-10px;bottom:0}}@media screen and (min-width:960px){.Sidebar-module--sidebar--X4z2p{width:calc(33.3% - 1.25rem)}.Sidebar-module--sidebar--X4z2p:nth-child(1n){float:left;margin-right:1.875rem;clear:none}.Sidebar-module--sidebar--X4z2p:last-child{margin-right:0}.Sidebar-module--sidebar--X4z2p:nth-child(3n){margin-right:0;float:right}.Sidebar-module--sidebar--X4z2p:nth-child(3n+1){clear:both}.Sidebar-module--sidebar__inner--Jdc5s{padding:2.5rem}}.Layout-module--layout--3Pyz6{max-width:66.875rem;margin-left:auto;margin-right:auto}.Layout-module--layout--3Pyz6:before{content:"";display:table}.Layout-module--layout--3Pyz6:after{content:"";display:table;clear:both}.Feed-module--feed__item--2D5rE{margin-bottom:1.5625rem}.Feed-module--feed__item--2D5rE:last-child{margin-bottom:.625rem}.Feed-module--feed__item-title--3nigr{font-size:1.47656rem;line-height:1.875rem;margin-top:0;margin-bottom:.625rem}.Feed-module--feed__item-title-link--iFMRs{color:#222}.Feed-module--feed__item-title-link--iFMRs:focus,.Feed-module--feed__item-title-link--iFMRs:hover{color:#222;border-bottom:1px solid #222}.Feed-module--feed__item-description--1uO8e{font-size:.875rem;line-height:1.25rem;margin-bottom:.9375rem}.Feed-module--feed__item-meta-time--3t1fg{font-size:.75rem;color:#222;font-weight:600;text-transform:uppercase}.Feed-module--feed__item-meta-divider--N-Q0A{margin:0 .3125rem}.Feed-module--feed__item-meta-category-link--23f8F{font-size:.75rem;color:#a9d159;font-weight:600;text-transform:uppercase}.Feed-module--feed__item-meta-category-link--23f8F:focus,.Feed-module--feed__item-meta-category-link--23f8F:hover{color:#918d40}.Feed-module--feed__item-readmore--1u6bI{font-size:.875rem;color:#918d40}.Feed-module--feed__item-readmore--1u6bI:focus,.Feed-module--feed__item-readmore--1u6bI:hover{color:#918d40;border-bottom:1px solid #918d40}.Page-module--page--2nMky{margin-bottom:2.5rem}.Page-module--page__inner--2M_vz{padding:1.5625rem 1.25rem}.Page-module--page__title--GPD8L{font-size:1.575rem;font-weight:600;line-height:2.5rem;margin-top:0;margin-bottom:1.8125rem}.Page-module--page__body--Ic6i6{font-size:.875rem;line-height:1.25rem;margin:0 0 1.25rem}@media screen and (min-width:685px){.Page-module--page--2nMky{width:calc(58.275% - .78125rem)}.Page-module--page--2nMky:nth-child(1n){float:left;margin-right:1.875rem;clear:none}.Page-module--page--2nMky:last-child{margin-right:0}.Page-module--page--2nMky:nth-child(12n){margin-right:0;float:right}.Page-module--page--2nMky:nth-child(12n+1){clear:both}.Page-module--page__inner--2M_vz{padding:1.875rem 1.25rem}}@media screen and (min-width:960px){.Page-module--page--2nMky{width:calc(66.6% - .625rem)}.Page-module--page--2nMky:nth-child(1n){float:left;margin-right:1.875rem;clear:none}.Page-module--page--2nMky:last-child{margin-right:0}.Page-module--page--2nMky:nth-child(3n){margin-right:0;float:right}.Page-module--page--2nMky:nth-child(3n+1){clear:both}.Page-module--page__inner--2M_vz{padding:2.5rem 2.1875rem}}.Pagination-module--pagination--2H3nO{margin-top:2.5rem;display:flex}.Pagination-module--pagination__prev--bet5s{width:50%;text-align:left}.Pagination-module--pagination__prev-link--1Nzs6{color:#a9d159;font-size:1.625rem;font-weight:700}.Pagination-module--pagination__prev-link--1Nzs6:focus,.Pagination-module--pagination__prev-link--1Nzs6:hover{color:#918d40}.Pagination-module--pagination__prev-link--disable--Yklx9{pointer-events:none;color:#bbb}.Pagination-module--pagination__next--3hFiN{width:50%;text-align:right}.Pagination-module--pagination__next-link--3FUtA{color:#a9d159;font-size:1.625rem;font-weight:700}.Pagination-module--pagination__next-link--3FUtA:focus,.Pagination-module--pagination__next-link--3FUtA:hover{color:#918d40}.Pagination-module--pagination__next-link--disable--30UwZ{pointer-events:none;color:#bbb}.Author-module--author--2Yefr{border-top:1px solid #e6e6e6;max-width:43.75rem;padding-top:1.25rem;line-height:1.25rem;margin-top:1.25rem;margin-bottom:2.5rem}.Author-module--author__bio-twitter--n-O9n{display:block;text-decoration:underline}@media screen and (min-width:685px){.Author-module--author--2Yefr{margin-left:auto;margin-right:auto}}.Content-module--content--3p512{max-width:62.8125rem;padding:0 .9375rem;margin:0 auto}.Content-module--content__title--2BDW9{font-size:1.75rem;max-width:43.75rem;font-weight:600;text-align:center;line-height:2.0625rem;margin:1.25rem auto 0}.Content-module--content__body--2TrQ- figure{margin-bottom:1.25rem}.Content-module--content__body--2TrQ- figure blockquote{font-style:italic;text-align:center;margin-top:0;padding:1.25rem 0}.Content-module--content__body--2TrQ- figure blockquote p{max-width:43.75rem;font-size:1.47149rem;margin-top:1.25rem;margin-bottom:1.25rem;line-height:1.875rem}.Content-module--content__body--2TrQ- a{text-decoration:underline}.Content-module--content__body--2TrQ- *{max-width:43.75rem;margin-left:auto;margin-right:auto}.Content-module--content__body--2TrQ- img{max-width:100%;margin-top:.625rem;margin-bottom:.625rem}.Content-module--content__body--2TrQ- li ul{margin-bottom:.625rem}.Content-module--content__body--2TrQ- li p{line-height:1.25rem;margin-bottom:.625rem}.Content-module--content__body--2TrQ- h2{position:relative;padding:1rem 1.5rem;color:#fff;border-radius:.625rem;background:#0c0000}.Content-module--content__body--2TrQ- h2:after{position:absolute;bottom:-9px;left:1rem;width:0;height:0;content:"";border-color:#0c0000 transparent transparent;border-style:solid;border-width:10px 10px 0}.Content-module--content__body--2TrQ- h3{border-bottom:3px dotted #0c0000;padding:1rem 0}@media screen and (min-width:960px){.Content-module--content--3p512{padding:0}.Content-module--content__title--2BDW9{font-size:1.75rem;line-height:2.8125rem;margin-top:2.8125rem;margin-bottom:1.875rem}.Content-module--content__body--2TrQ-,.Content-module--content__body--2TrQ- p{font-size:.98438rem;line-height:1.40625rem;margin-bottom:1.40625rem}.Content-module--content__body--2TrQ- li p{line-height:1.25rem;margin-bottom:.625rem}}.Meta-module--meta__date--29eD7{font-style:italic}.Tags-module--tags--1L_ct{margin-bottom:.625rem}.Tags-module--tags__list--91FqN{list-style:none;margin:0 -.625rem;padding:0}.Tags-module--tags__list-item--1M30P{display:inline-block;margin:.625rem .3125rem}.Tags-module--tags__list-item-link--3SL_8{display:inline-block;height:2.1875rem;padding:0 1.5rem;line-height:2.1875rem;border:1px solid #e6e6e6;text-decoration:none;border-radius:1.25rem;color:#222}.Tags-module--tags__list-item-link--3SL_8:focus,.Tags-module--tags__list-item-link--3SL_8:hover{color:#918d40}.Post-module--post__comments--25y6I,.Post-module--post__footer--3WzWU{max-width:43.75rem;margin:0 auto;padding:0 .9375rem}.Post-module--post__home-button--16Kl0{display:block;max-width:5.625rem;height:2.1875rem;padding:0 1.5rem;line-height:2.1875rem;text-align:center;color:#222;border:1px solid #e6e6e6;border-radius:1.25rem;font-size:.875rem;font-weight:400;margin-left:auto;margin-right:auto;margin-top:1.25rem}.Post-module--post__home-button--16Kl0:focus,.Post-module--post__home-button--16Kl0:hover{color:#918d40}@media screen and (min-width:960px){.Post-module--post__comments--25y6I,.Post-module--post__footer--3WzWU{padding:0}.Post-module--post__home-button--16Kl0{position:fixed;max-width:auto;margin:0;top:30px;left:30px}}</style><meta name="generator" content="Gatsby 2.32.13"/><link rel="alternate" type="application/rss+xml" title="かえるのひみつきち" href="/rss.xml"/><style type="text/css">
    .anchor.before {
      position: absolute;
      top: 0;
      left: 0;
      transform: translateX(-100%);
      padding-right: 4px;
    }
    .anchor.after {
      display: inline-block;
      padding-left: 4px;
    }
    h1 .anchor svg,
    h2 .anchor svg,
    h3 .anchor svg,
    h4 .anchor svg,
    h5 .anchor svg,
    h6 .anchor svg {
      visibility: hidden;
    }
    h1:hover .anchor svg,
    h2:hover .anchor svg,
    h3:hover .anchor svg,
    h4:hover .anchor svg,
    h5:hover .anchor svg,
    h6:hover .anchor svg,
    h1 .anchor:focus svg,
    h2 .anchor:focus svg,
    h3 .anchor:focus svg,
    h4 .anchor:focus svg,
    h5 .anchor:focus svg,
    h6 .anchor:focus svg {
      visibility: visible;
    }
  </style><script>
    document.addEventListener("DOMContentLoaded", function(event) {
      var hash = window.decodeURI(location.hash.replace('#', ''))
      if (hash !== '') {
        var element = document.getElementById(hash)
        if (element) {
          var scrollTop = window.pageYOffset || document.documentElement.scrollTop || document.body.scrollTop
          var clientTop = document.documentElement.clientTop || document.body.clientTop || 0
          var offset = element.getBoundingClientRect().top + scrollTop - clientTop
          // Wait for the browser to finish rendering before scrolling.
          setTimeout((function() {
            window.scrollTo(0, offset - 0)
          }), 0)
        }
      }
    })
  </script><link rel="preconnect dns-prefetch" href="https://www.google-analytics.com"/><script async="" src="https://www.googletagmanager.com/gtag/js?id=UA-122086587-6"></script><script>
      
      
      if(true) {
        window.dataLayer = window.dataLayer || [];
        function gtag(){window.dataLayer && window.dataLayer.push(arguments);}
        gtag('js', new Date());

        gtag('config', 'UA-122086587-6', {"send_page_view":false});
      }
      </script><link rel="sitemap" type="application/xml" href="/sitemap.xml"/><link rel="icon" href="/favicon-32x32.png?v=a0f47f11c0e7e9c18dcf5ce2a040fc9d" type="image/png"/><link rel="manifest" href="/manifest.webmanifest" crossorigin="anonymous"/><meta name="theme-color" content="#F7A046"/><link rel="apple-touch-icon" sizes="48x48" href="/icons/icon-48x48.png?v=a0f47f11c0e7e9c18dcf5ce2a040fc9d"/><link rel="apple-touch-icon" sizes="72x72" href="/icons/icon-72x72.png?v=a0f47f11c0e7e9c18dcf5ce2a040fc9d"/><link rel="apple-touch-icon" sizes="96x96" href="/icons/icon-96x96.png?v=a0f47f11c0e7e9c18dcf5ce2a040fc9d"/><link rel="apple-touch-icon" sizes="144x144" href="/icons/icon-144x144.png?v=a0f47f11c0e7e9c18dcf5ce2a040fc9d"/><link rel="apple-touch-icon" sizes="192x192" href="/icons/icon-192x192.png?v=a0f47f11c0e7e9c18dcf5ce2a040fc9d"/><link rel="apple-touch-icon" sizes="256x256" href="/icons/icon-256x256.png?v=a0f47f11c0e7e9c18dcf5ce2a040fc9d"/><link rel="apple-touch-icon" sizes="384x384" href="/icons/icon-384x384.png?v=a0f47f11c0e7e9c18dcf5ce2a040fc9d"/><link rel="apple-touch-icon" sizes="512x512" href="/icons/icon-512x512.png?v=a0f47f11c0e7e9c18dcf5ce2a040fc9d"/><title data-react-helmet="true">xv6OSを真面目に読みこんでカーネルを完全に理解する -ブートストラップ編- - かえるのひみつきち</title><meta data-react-helmet="true" name="description" content="教育用OSのxv6OSのソースコードを読んでカーネルについて学んでいきます。この記事ではxv6OSのブートストラップを読み解きます。"/><meta data-react-helmet="true" property="og:site_name" content="xv6OSを真面目に読みこんでカーネルを完全に理解する -ブートストラップ編- - かえるのひみつきち"/><meta data-react-helmet="true" property="og:image" content="https://kashiwaba-yuki.com/static/a1219355b6fca5aca448f0393c8a403a/unix-xv6-001-bootstrap.png"/><meta data-react-helmet="true" name="twitter:card" content="summary_large_image"/><meta data-react-helmet="true" name="twitter:title" content="xv6OSを真面目に読みこんでカーネルを完全に理解する -ブートストラップ編- - かえるのひみつきち"/><meta data-react-helmet="true" name="twitter:description" content="教育用OSのxv6OSのソースコードを読んでカーネルについて学んでいきます。この記事ではxv6OSのブートストラップを読み解きます。"/><meta data-react-helmet="true" name="twitter:image" content="https://kashiwaba-yuki.com/static/a1219355b6fca5aca448f0393c8a403a/unix-xv6-001-bootstrap.png"/><link as="script" rel="preload" href="/webpack-runtime-a3c0f166cb4b802ff58f.js"/><link as="script" rel="preload" href="/framework-3761df4ab6ee9f056936.js"/><link as="script" rel="preload" href="/532a2f07-92db97c0addf07d5cb73.js"/><link as="script" rel="preload" href="/dc6a8720040df98778fe970bf6c000a41750d3ae-7f15a6c248118ef4fef1.js"/><link as="script" rel="preload" href="/app-d190fa369444a992009d.js"/><link as="script" rel="preload" href="/styles-407fe62976dc5310c43e.js"/><link as="script" rel="preload" href="/cd95ea5cbd2c605f26db819f07999610c9ff4310-c2f05dc74373de400085.js"/><link as="script" rel="preload" href="/component---src-templates-post-template-js-381c1b847824134fa4bd.js"/><link as="fetch" rel="preload" href="/page-data/unix-xv6-001-bootstrap/page-data.json" crossorigin="anonymous"/><link as="fetch" rel="preload" href="/page-data/sq/d/251939775.json" crossorigin="anonymous"/><link as="fetch" rel="preload" href="/page-data/sq/d/401334301.json" crossorigin="anonymous"/><link as="fetch" rel="preload" href="/page-data/sq/d/825871152.json" crossorigin="anonymous"/><link as="fetch" rel="preload" href="/page-data/app-data.json" crossorigin="anonymous"/></head><body><div id="___gatsby"><div style="outline:none" tabindex="-1" id="gatsby-focus-wrapper"><div class="Layout-module--layout--3Pyz6"><div><a class="Post-module--post__home-button--16Kl0" href="/">All Articles</a><div><div class="Content-module--content--3p512"><h1 class="Content-module--content__title--2BDW9">xv6OSを真面目に読みこんでカーネルを完全に理解する -ブートストラップ編-</h1><div class="Content-module--content__body--2TrQ-"><p><a href="https://amzn.to/3q8TU3K" target="_blank" rel="nofollow noopener noreferrer">はじめてのOSコードリーディング ~UNIX V6で学ぶカーネルのしくみ</a>にインスパイアされて<a href="https://github.com/mit-pdos/xv6-public" target="_blank" rel="nofollow noopener noreferrer">xv6 OS</a>を読んでます。</p>
<p>リバースエンジニアリングに強くなりたいのと、カーネルとかOSに詳しくなりたいと思っています。</p>
<p><a href="https://amzn.to/3I6fkVt" target="_blank" rel="nofollow noopener noreferrer">詳解 Linuxカーネル</a>が結構重かったので、もう少し軽めのところから始めたいと思っていたところ、UNIX V6というOSがトータルで1万行くらいのコード量で、人類でもギリギリ理解できるということを知り、興味を持ちました。</p>
<p>ただ、UNIX V6自体はx86CPUでは動作しないため、基本的には、UNIXv6をX86アーキテクチャで動くようにした<a href="https://github.com/mit-pdos/xv6-public" target="_blank" rel="nofollow noopener noreferrer">xv6 OS</a>のリポジトリをForkした<a href="https://github.com/kash1064/xv6-public" target="_blank" rel="nofollow noopener noreferrer">kash1064/xv6-public: xv6 OS</a>のソースコードを読んでいくことにしました。</p>
<p>xv6は、もともとMITのOSの講義のために開発された教育用のOSです。</p>
<p>参考：<a href="https://pdos.csail.mit.edu/6.828/2012/xv6.html" target="_blank" rel="nofollow noopener noreferrer">Xv6, a simple Unix-like teaching operating system</a></p>
<p>この講義で使用するテキストもオンラインで配布されています。</p>
<p>参考：<a href="https://pdos.csail.mit.edu/6.828/2012/xv6/book-rev7.pdf" target="_blank" rel="nofollow noopener noreferrer">xv6 a simple, Unix-like teaching operating system</a></p>
<p>Fork元のリポジトリは現在メンテナンスされておらず、RISC-Vで動作するUNIXv6のメンテナンスが行われています。</p>
<!-- omit in toc -->
<h2 id="もくじ" style="position:relative;"><a href="#%E3%82%82%E3%81%8F%E3%81%98" aria-label="もくじ permalink" class="anchor before"><svg aria-hidden="true" focusable="false" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>もくじ</h2>
<ul>
<li>
<p><a href="#%E3%82%A4%E3%83%A1%E3%83%BC%E3%82%B8%E3%83%95%E3%82%A1%E3%82%A4%E3%83%AB%E3%81%AE%E6%A7%8B%E9%80%A0">イメージファイルの構造</a></p>
<ul>
<li><a href="#xv6img">xv6.img</a></li>
<li><a href="#fsimg">fs.img</a></li>
</ul>
</li>
<li>
<p><a href="#bootblock%E3%82%92%E8%AA%AD%E3%82%80">bootblockを読む</a></p>
<ul>
<li><a href="#%E3%82%B3%E3%83%B3%E3%83%91%E3%82%A4%E3%83%A9">コンパイラ</a></li>
<li><a href="#%E3%83%A1%E3%83%A2%E4%BD%8D%E7%BD%AE%E7%8B%AC%E7%AB%8B%E3%81%AA%E3%82%B3%E3%83%BC%E3%83%89pic">メモ：位置独立なコード(PIC)</a></li>
<li><a href="#bootmainc%E3%81%AE%E5%85%A8%E4%BD%93%E5%83%8F">bootmain.cの全体像</a></li>
<li><a href="#bootblocko%E3%81%AE%E5%85%A8%E4%BD%93%E5%83%8F">bootblock.oの全体像</a></li>
<li><a href="#%E3%83%96%E3%83%BC%E3%83%88%E3%83%97%E3%83%AD%E3%82%B0%E3%83%A9%E3%83%A0%E3%81%AE%E3%83%AA%E3%83%B3%E3%82%AF">ブートプログラムのリンク</a></li>
<li><a href="#%E3%83%AA%E3%82%A2%E3%83%AB%E3%83%A2%E3%83%BC%E3%83%89%E3%81%A8%E3%83%97%E3%83%AD%E3%83%86%E3%82%AF%E3%83%88%E3%83%A2%E3%83%BC%E3%83%89">リアルモードとプロテクトモード</a></li>
<li><a href="#%E3%83%AA%E3%82%A2%E3%83%AB%E3%83%A2%E3%83%BC%E3%83%89%E3%81%A7%E8%B5%B7%E5%8B%95%E3%81%99%E3%82%8B">リアルモードで起動する</a></li>
<li><a href="#cli%E3%81%A8sti%E3%81%A7cpu%E5%89%B2%E8%BE%BC%E3%81%BF%E3%82%92%E7%A6%81%E6%AD%A2">cliとstiでCPU割込みを禁止</a></li>
<li><a href="#%E3%82%BB%E3%82%B0%E3%83%A1%E3%83%B3%E3%83%88%E3%83%AC%E3%82%B8%E3%82%B9%E3%82%BF%E3%81%AE%E5%88%9D%E6%9C%9F%E5%8C%96">セグメントレジスタの初期化</a></li>
<li><a href="#a20-line%E3%81%AE%E6%9C%89%E5%8A%B9%E5%8C%96">A20 Lineの有効化</a></li>
<li><a href="#%E3%83%97%E3%83%AD%E3%83%86%E3%82%AF%E3%83%88%E3%83%A2%E3%83%BC%E3%83%89%E3%81%B8%E3%81%AE%E7%A7%BB%E8%A1%8C">プロテクトモードへの移行</a></li>
<li><a href="#%E3%83%97%E3%83%AD%E3%83%86%E3%82%AF%E3%83%88%E3%83%A2%E3%83%BC%E3%83%89%E3%81%A7%E3%81%AE%E3%83%A1%E3%83%A2%E3%83%AA%E3%82%A2%E3%83%89%E3%83%AC%E3%82%B9%E5%8F%82%E7%85%A7">プロテクトモードでのメモリアドレス参照</a></li>
<li><a href="#lgdt-gdtdesc">lgdt gdtdesc</a></li>
<li><a href="#32bit%E3%83%A2%E3%83%BC%E3%83%89%E3%81%AE%E9%96%8B%E5%A7%8B">32bitモードの開始</a></li>
<li><a href="#%E3%81%AA%E3%81%9Cljmp%E5%91%BD%E4%BB%A4%E3%82%92%E4%BD%BF%E7%94%A8%E3%81%99%E3%82%8B%E3%81%AE%E3%81%8B">なぜljmp命令を使用するのか</a></li>
<li><a href="#%E3%83%97%E3%83%AD%E3%83%86%E3%82%AF%E3%83%88%E3%83%A2%E3%83%BC%E3%83%89%E7%A7%BB%E8%A1%8C%E5%BE%8C%E3%81%AE%E8%A8%AD%E5%AE%9A">プロテクトモード移行後の設定</a></li>
<li><a href="#%E3%82%BB%E3%82%B0%E3%83%A1%E3%83%B3%E3%83%88%E3%83%AC%E3%82%B8%E3%82%B9%E3%82%BF%E3%81%AE%E5%88%9D%E6%9C%9F%E5%8C%96-1">セグメントレジスタの初期化</a></li>
<li><a href="#bootmainc%E3%81%AE%E5%91%BC%E3%81%B3%E5%87%BA%E3%81%97">bootmain.cの呼び出し</a></li>
<li><a href="#%E3%82%AB%E3%83%BC%E3%83%8D%E3%83%AB%E3%81%AE%E3%83%AD%E3%83%BC%E3%83%89">カーネルのロード</a></li>
<li><a href="#%E3%83%87%E3%82%A3%E3%82%B9%E3%82%AF%E3%81%8B%E3%82%89elf%E3%82%AB%E3%83%BC%E3%83%8D%E3%83%AB%E3%82%A4%E3%83%A1%E3%83%BC%E3%82%B8%E3%82%92%E3%83%AD%E3%83%BC%E3%83%89%E3%81%99%E3%82%8B">ディスクからELFカーネルイメージをロードする</a></li>
<li><a href="#%E3%83%87%E3%82%A3%E3%82%B9%E3%82%AF%E3%81%8B%E3%82%89%E3%82%BB%E3%82%AF%E3%82%BF%E3%82%92%E8%AA%AD%E3%81%BF%E5%8F%96%E3%82%8B">ディスクからセクタを読み取る</a></li>
<li><a href="#%E8%AA%AD%E3%81%BF%E8%BE%BC%E3%82%93%E3%81%A0%E3%82%AB%E3%83%BC%E3%83%8D%E3%83%AB%E3%81%AE%E7%A2%BA%E8%AA%8D">読み込んだカーネルの確認</a></li>
<li><a href="#%E3%83%97%E3%83%AD%E3%82%B0%E3%83%A9%E3%83%A0%E3%83%98%E3%83%83%E3%83%80%E3%81%AE%E8%AA%AD%E3%81%BF%E8%BE%BC%E3%81%BF">プログラムヘッダの読み込み</a></li>
</ul>
</li>
<li><a href="#%E3%81%BE%E3%81%A8%E3%82%81">まとめ</a></li>
<li><a href="#%E5%8F%82%E8%80%83%E6%9B%B8%E7%B1%8D">参考書籍</a></li>
</ul>
<h2 id="イメージファイルの構造" style="position:relative;"><a href="#%E3%82%A4%E3%83%A1%E3%83%BC%E3%82%B8%E3%83%95%E3%82%A1%E3%82%A4%E3%83%AB%E3%81%AE%E6%A7%8B%E9%80%A0" aria-label="イメージファイルの構造 permalink" class="anchor before"><svg aria-hidden="true" focusable="false" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>イメージファイルの構造</h2>
<p>xv6は、<code class="language-text">xv6.img</code>と<code class="language-text">fs.img</code>という2つのイメージファイルを使用して起動します。</p>
<h3 id="xv6img" style="position:relative;"><a href="#xv6img" aria-label="xv6img permalink" class="anchor before"><svg aria-hidden="true" focusable="false" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>xv6.img</h3>
<p><code class="language-text">xv6.img</code>は、以下のような構造です。</p>
<div class="gatsby-highlight" data-language="bash"><pre class="language-bash"><code class="language-bash"><span class="token comment"># Makefile</span>
xv6.img: bootblock kernel
	<span class="token function">dd</span> <span class="token assign-left variable">if</span><span class="token operator">=</span>/dev/zero <span class="token assign-left variable">of</span><span class="token operator">=</span>xv6.img <span class="token assign-left variable">count</span><span class="token operator">=</span><span class="token number">10000</span>
	<span class="token function">dd</span> <span class="token assign-left variable">if</span><span class="token operator">=</span>bootblock <span class="token assign-left variable">of</span><span class="token operator">=</span>xv6.img <span class="token assign-left variable">conv</span><span class="token operator">=</span>notrunc
	<span class="token function">dd</span> <span class="token assign-left variable">if</span><span class="token operator">=</span>kernel <span class="token assign-left variable">of</span><span class="token operator">=</span>xv6.img <span class="token assign-left variable">seek</span><span class="token operator">=</span><span class="token number">1</span> <span class="token assign-left variable">conv</span><span class="token operator">=</span>notrunc</code></pre></div>
<p><code class="language-text">dd if=/dev/zero of=xv6.img count=10000</code>は、<code class="language-text">512*10^4</code>バイト(51.2MBバイト)を<code class="language-text">/dev/zero</code>から読みだして<code class="language-text">xv6.img</code>として保存します。</p>
<p>ddコマンドのブロックサイズ(<code class="language-text">bs</code>)はデフォルトで512であるため、このような挙動になります。</p>
<p><code class="language-text">conv=notrunc</code>は、元のファイルのサイズを維持したまま、指定したバイナリの書き込みを行うオプションです。</p>
<p>これによって、512バイトのbootblock が、<code class="language-text">xv6.img</code>の先頭から書き込まれた際に、元の<code class="language-text">xv6.img</code>のサイズが維持されます。</p>
<p><code class="language-text">seek=1</code>は、ブロック単位で書き込み開始位置をスキップするオプションです。</p>
<p>ブロックサイズはデフォルトでは512であるため、<code class="language-text">dd if=kernel of=xv6.img seek=1 conv=notrunc</code>は、先頭512バイト目からkernelを配置することを意味しています。</p>
<p>これらのコマンドを見てわかる通り、<code class="language-text">512*10^4</code>バイト(51.2MBバイト)の空のイメージファイルを生成した後、先頭512バイトにbootblockを配置し、さらにその後にkernelを配置しています。</p>
<p><span
      class="gatsby-resp-image-wrapper"
      style="position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 500px; "
    >
      <a
    class="gatsby-resp-image-link"
    href="/static/0ee723f0df4390ef428db10febeb6cfd/0b533/image-8.png"
    style="display: block"
    target="_blank"
    rel="noopener"
  >
    <span
    class="gatsby-resp-image-background-image"
    style="padding-bottom: 75%; position: relative; bottom: 0; left: 0; background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAPCAYAAADkmO9VAAAACXBIWXMAARlAAAEZQAGA43XUAAABiElEQVQ4y8WU6XaCMBBGff8Hah+gdtGiApGqaCsgFgmgHDZ3viZxpaL1X3POPWFmwiXDVsF+bLdbRFFUII5jJEki4Me/65vNRpyb5/lBg0oQ+IjY4vVqhW9KQcwRNMsWEMNCo9dHUx+ADM1Tnq2xnAm2ZcLlcon1es12uIE9cVHTh3gfGJAGJl47AzxUa3h8qeNZ0yF9mixviDXDsYOcdXUhxNlwPAeNLxmyQRiqmMlIEygmQWufaw5lGI5ZLuTBIeGHFF0qo+8T6B5HFce7WN3nCHqeAtszWcsn4YGC0Ju5+JjI6LkEXVdlEKijBhRLOsacjsuEtCgstHwhpDshn+t6FW/dp13MZL0rwuMOC8LQFYt1ry1knL6vCQ4xr3WpgrFnYZ4tQKmLsW0jCKbgD7ggpNMJa1GCNm6hfaS5ZxfzGrElWK7BdpjfbjlOYqTzBOkiZSTlsHrG6mE4E6/bzZazbI57B/96zoWlO8yyrHC1a4hu+Nf1L8J7x13CNE3FveHzX1z72/wARuV7fAc3xmkAAAAASUVORK5CYII='); background-size: cover; display: block;"
  ></span>
  <picture>
          <source
              srcset="/static/0ee723f0df4390ef428db10febeb6cfd/8ac56/image-8.webp 240w,
/static/0ee723f0df4390ef428db10febeb6cfd/d3be9/image-8.webp 480w,
/static/0ee723f0df4390ef428db10febeb6cfd/b0a15/image-8.webp 500w"
              sizes="(max-width: 500px) 100vw, 500px"
              type="image/webp"
            />
          <source
            srcset="/static/0ee723f0df4390ef428db10febeb6cfd/8ff5a/image-8.png 240w,
/static/0ee723f0df4390ef428db10febeb6cfd/e85cb/image-8.png 480w,
/static/0ee723f0df4390ef428db10febeb6cfd/0b533/image-8.png 500w"
            sizes="(max-width: 500px) 100vw, 500px"
            type="image/png"
          />
          <img
            class="gatsby-resp-image-image"
            src="/static/0ee723f0df4390ef428db10febeb6cfd/0b533/image-8.png"
            alt="img"
            title="img"
            loading="lazy"
            style="width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;"
          />
        </picture>
  </a>
    </span></p>
<p>空になったままのスペースはシステムが使用します。</p>
<h3 id="fsimg" style="position:relative;"><a href="#fsimg" aria-label="fsimg permalink" class="anchor before"><svg aria-hidden="true" focusable="false" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>fs.img</h3>
<p><code class="language-text">fs.img</code>は以下のような構造です。</p>
<div class="gatsby-highlight" data-language="bash"><pre class="language-bash"><code class="language-bash"><span class="token comment"># Makefile</span>
<span class="token assign-left variable">UPROGS</span><span class="token operator">=</span><span class="token punctuation">\</span>
	_cat<span class="token punctuation">\</span>
	_echo<span class="token punctuation">\</span>
	_forktest<span class="token punctuation">\</span>
	_grep<span class="token punctuation">\</span>
	_init<span class="token punctuation">\</span>
	_kill<span class="token punctuation">\</span>
	_ln<span class="token punctuation">\</span>
	_ls<span class="token punctuation">\</span>
	_mkdir<span class="token punctuation">\</span>
	_rm<span class="token punctuation">\</span>
	_sh<span class="token punctuation">\</span>
	_stressfs<span class="token punctuation">\</span>
	_usertests<span class="token punctuation">\</span>
	_wc<span class="token punctuation">\</span>
	_zombie<span class="token punctuation">\</span>

mkfs: mkfs.c fs.h
	gcc -Werror -Wall -o <span class="token function">mkfs</span> mkfs.c

fs.img: <span class="token function">mkfs</span> README <span class="token variable"><span class="token variable">$(</span>UPROGS<span class="token variable">)</span></span>
	./mkfs fs.img README <span class="token variable"><span class="token variable">$(</span>UPROGS<span class="token variable">)</span></span></code></pre></div>
<p>各種コマンドプログラムの本体やREADMEが格納されています。</p>
<p>ユーザが操作するディスクです。</p>
<h2 id="bootblockを読む" style="position:relative;"><a href="#bootblock%E3%82%92%E8%AA%AD%E3%82%80" aria-label="bootblockを読む permalink" class="anchor before"><svg aria-hidden="true" focusable="false" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>bootblockを読む</h2>
<p>まずはbootblockについてです。</p>
<div class="gatsby-highlight" data-language="bash"><pre class="language-bash"><code class="language-bash">bootblock: bootasm.S bootmain.c
	<span class="token variable"><span class="token variable">$(</span>CC<span class="token variable">)</span></span> <span class="token variable"><span class="token variable">$(</span>CFLAGS<span class="token variable">)</span></span> -fno-pic -O -nostdinc -I. -c bootmain.c
	<span class="token variable"><span class="token variable">$(</span>CC<span class="token variable">)</span></span> <span class="token variable"><span class="token variable">$(</span>CFLAGS<span class="token variable">)</span></span> -fno-pic -nostdinc -I. -c bootasm.S
	<span class="token variable"><span class="token variable">$(</span>LD<span class="token variable">)</span></span> <span class="token variable"><span class="token variable">$(</span>LDFLAGS<span class="token variable">)</span></span> -N -e start -Ttext 0x7C00 -o bootblock.o bootasm.o bootmain.o
	<span class="token variable"><span class="token variable">$(</span>OBJDUMP<span class="token variable">)</span></span> -S bootblock.o <span class="token operator">></span> bootblock.asm
	<span class="token variable"><span class="token variable">$(</span>OBJCOPY<span class="token variable">)</span></span> -S -O binary -j .text bootblock.o bootblock
	./sign.pl bootblock</code></pre></div>
<p>ビルドオプションから見ていきます。</p>
<h3 id="コンパイラ" style="position:relative;"><a href="#%E3%82%B3%E3%83%B3%E3%83%91%E3%82%A4%E3%83%A9" aria-label="コンパイラ permalink" class="anchor before"><svg aria-hidden="true" focusable="false" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>コンパイラ</h3>
<p>以下は、Makefileの中の<code class="language-text">$(CC)</code>に関連した箇所です。</p>
<div class="gatsby-highlight" data-language="bash"><pre class="language-bash"><code class="language-bash"><span class="token comment"># Cross-compiling (e.g., on Mac OS X)</span>
<span class="token comment"># TOOLPREFIX = i386-jos-elf</span>

<span class="token comment"># Using native tools (e.g., on X86 Linux)</span>
<span class="token comment">#TOOLPREFIX = </span>

<span class="token comment"># Try to infer the correct TOOLPREFIX if not set</span>
ifndef TOOLPREFIX
TOOLPREFIX :<span class="token operator">=</span> <span class="token variable"><span class="token variable">$(</span>shell <span class="token keyword">if</span> i386-jos-elf-objdump -i <span class="token operator"><span class="token file-descriptor important">2</span>></span><span class="token file-descriptor important">&amp;1</span> <span class="token operator">|</span> <span class="token function">grep</span> <span class="token string">'^elf32-i386$$'</span> <span class="token operator">></span>/dev/null <span class="token operator"><span class="token file-descriptor important">2</span>></span><span class="token file-descriptor important">&amp;1</span><span class="token punctuation">;</span> <span class="token punctuation">\</span>
	<span class="token keyword">then</span> <span class="token builtin class-name">echo</span> <span class="token string">'i386-jos-elf-'</span><span class="token punctuation">;</span> <span class="token punctuation">\</span>
	<span class="token keyword">elif</span> objdump -i <span class="token operator"><span class="token file-descriptor important">2</span>></span><span class="token file-descriptor important">&amp;1</span> <span class="token operator">|</span> <span class="token function">grep</span> <span class="token string">'elf32-i386'</span> <span class="token operator">></span>/dev/null <span class="token operator"><span class="token file-descriptor important">2</span>></span><span class="token file-descriptor important">&amp;1</span><span class="token punctuation">;</span> <span class="token punctuation">\</span>
	<span class="token keyword">then</span> <span class="token builtin class-name">echo</span> <span class="token string">''</span><span class="token punctuation">;</span> <span class="token punctuation">\</span>
	<span class="token keyword">else</span> <span class="token builtin class-name">echo</span> <span class="token string">"***"</span> <span class="token operator"><span class="token file-descriptor important">1</span>></span><span class="token file-descriptor important">&amp;2</span><span class="token punctuation">;</span> <span class="token punctuation">\</span>
	<span class="token builtin class-name">echo</span> <span class="token string">"*** Error: Couldn't find an i386-*-elf version of GCC/binutils."</span> <span class="token operator"><span class="token file-descriptor important">1</span>></span><span class="token file-descriptor important">&amp;2</span><span class="token punctuation">;</span> <span class="token punctuation">\</span>
	<span class="token builtin class-name">echo</span> <span class="token string">"*** Is the directory with i386-jos-elf-gcc in your PATH?"</span> <span class="token operator"><span class="token file-descriptor important">1</span>></span><span class="token file-descriptor important">&amp;2</span><span class="token punctuation">;</span> <span class="token punctuation">\</span>
	<span class="token builtin class-name">echo</span> <span class="token string">"*** If your i386-*-elf toolchain is installed with a command"</span> <span class="token operator"><span class="token file-descriptor important">1</span>></span><span class="token file-descriptor important">&amp;2</span><span class="token punctuation">;</span> <span class="token punctuation">\</span>
	<span class="token builtin class-name">echo</span> <span class="token string">"*** prefix other than 'i386-jos-elf-', set your TOOLPREFIX"</span> <span class="token operator"><span class="token file-descriptor important">1</span>></span><span class="token file-descriptor important">&amp;2</span><span class="token punctuation">;</span> <span class="token punctuation">\</span>
	<span class="token builtin class-name">echo</span> <span class="token string">"*** environment variable to that prefix and run 'make' again."</span> <span class="token operator"><span class="token file-descriptor important">1</span>></span><span class="token file-descriptor important">&amp;2</span><span class="token punctuation">;</span> <span class="token punctuation">\</span>
	<span class="token builtin class-name">echo</span> <span class="token string">"*** To turn off this error, run 'gmake TOOLPREFIX= ...'."</span> <span class="token operator"><span class="token file-descriptor important">1</span>></span><span class="token file-descriptor important">&amp;2</span><span class="token punctuation">;</span> <span class="token punctuation">\</span>
	<span class="token builtin class-name">echo</span> <span class="token string">"***"</span> <span class="token operator"><span class="token file-descriptor important">1</span>></span><span class="token file-descriptor important">&amp;2</span><span class="token punctuation">;</span> <span class="token builtin class-name">exit</span> <span class="token number">1</span><span class="token punctuation">;</span> <span class="token keyword">fi</span><span class="token variable">)</span></span>
endif

CC <span class="token operator">=</span> <span class="token variable"><span class="token variable">$(</span>TOOLPREFIX<span class="token variable">)</span></span>gcc</code></pre></div>
<p>デフォルトでは<code class="language-text">gcc</code>を使ってコンパイルします。</p>
<p>もしLinuxではなくMacOSなどの環境でビルドする場合は、<code class="language-text">TOOLPREFIX</code>の設定を変更してクロスコンパイルする必要があります。</p>
<p>参考：<a href="https://qiita.com/maru-n@github/items/9cf83944403b3fbb8422" target="_blank" rel="nofollow noopener noreferrer">OS X Yosemiteでxv6をbuildして動かすまで - Qiita</a></p>
<p>続いて、以下は<code class="language-text">CFLAGS</code>の箇所です。</p>
<div class="gatsby-highlight" data-language="bash"><pre class="language-bash"><code class="language-bash">CFLAGS <span class="token operator">=</span> -fno-pic -static -fno-builtin -fno-strict-aliasing -O2 -Wall -MD -ggdb -m32 -Werror -fno-omit-frame-pointer
CFLAGS <span class="token operator">+=</span> <span class="token variable"><span class="token variable">$(</span>shell <span class="token punctuation">$(</span>CC<span class="token punctuation">)</span> -fno-stack-protector -E -x c /dev/null <span class="token operator">></span>/dev/null <span class="token operator"><span class="token file-descriptor important">2</span>></span><span class="token file-descriptor important">&amp;1</span> <span class="token operator">&amp;&amp;</span> <span class="token builtin class-name">echo</span> -fno-stack-protector<span class="token variable">)</span></span></code></pre></div>
<p>オプションの部分については割愛しますが、デフォルトの設定を追っていきます。</p>
<p>参考：<a href="https://linuxjm.osdn.jp/html/GNU_gcc/man1/gcc.1.html" target="_blank" rel="nofollow noopener noreferrer">Man page of GCC</a></p>
<table>
<thead>
<tr>
<th align="center">オプション</th>
<th align="center">用途</th>
</tr>
</thead>
<tbody>
<tr>
<td align="center">-fno-pic</td>
<td align="center">位置独立なコード(PIC)を生成しない</td>
</tr>
<tr>
<td align="center">-static</td>
<td align="center">プログラムを静的リンクでコンパイルする</td>
</tr>
<tr>
<td align="center">-fno-builtin</td>
<td align="center">コンパイラに組み込まれているビルドイン関数を利用しない</td>
</tr>
<tr>
<td align="center">-fno-strict-aliasing</td>
<td align="center">厳密なエイリアシングの無効化</td>
</tr>
<tr>
<td align="center">-O2</td>
<td align="center">サポートされているすべての最適化オプションを有効化</td>
</tr>
<tr>
<td align="center">-Wall</td>
<td align="center">すべてのコンパイラの警告メッセージを有効化</td>
</tr>
<tr>
<td align="center">-MD</td>
<td align="center">システムヘッダーファイルとユーザーヘッダーファイルの両方を一覧</td>
</tr>
<tr>
<td align="center">-ggdb</td>
<td align="center">gdbを対象としたデバッグ情報を生成</td>
</tr>
<tr>
<td align="center">-m32</td>
<td align="center">32bitオブジェクトとしてコンパイル</td>
</tr>
<tr>
<td align="center">-Werror</td>
<td align="center">未使用の関数引数があった場合、コンパイルエラーとする</td>
</tr>
<tr>
<td align="center">-fno-omit-frame-pointer</td>
<td align="center">フレームポインタを必要としない関数のレジスタにもフレームポインタを保持する</td>
</tr>
</tbody>
</table>
<h3 id="メモ位置独立なコードpic" style="position:relative;"><a href="#%E3%83%A1%E3%83%A2%E4%BD%8D%E7%BD%AE%E7%8B%AC%E7%AB%8B%E3%81%AA%E3%82%B3%E3%83%BC%E3%83%89pic" aria-label="メモ位置独立なコードpic permalink" class="anchor before"><svg aria-hidden="true" focusable="false" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>メモ：位置独立なコード(PIC)</h3>
<p>位置独立なコード(PIC)または位置独立実行形式(PIE)とは、メモリのどこに配置されても正しく実行できる機械語を指します。</p>
<p>PICは主に共有ライブラリなどに利用されます。</p>
<p>参考：<a href="https://eli.thegreenplace.net/2011/11/03/position-independent-code-pic-in-shared-libraries/" target="_blank" rel="nofollow noopener noreferrer">Position Independent Code (PIC) in shared libraries - Eli Bendersky’s website</a></p>
<p>参考：<a href="http://0xcc.net/blog/archives/000107.html" target="_blank" rel="nofollow noopener noreferrer">Linux の共有ライブラリを作るとき PIC でコンパイルするのはなぜか - bkブログ</a></p>
<h3 id="bootmaincの全体像" style="position:relative;"><a href="#bootmainc%E3%81%AE%E5%85%A8%E4%BD%93%E5%83%8F" aria-label="bootmaincの全体像 permalink" class="anchor before"><svg aria-hidden="true" focusable="false" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>bootmain.cの全体像</h3>
<p>xv6のビルドを行う際、まず初めに以下の<code class="language-text">bootmain.o</code>から、<code class="language-text">bootmain.o</code>が生成されます。</p>
<div class="gatsby-highlight" data-language="c"><pre class="language-c"><code class="language-c"><span class="token comment">// Boot loader.</span>
<span class="token comment">//</span>
<span class="token comment">// Part of the boot block, along with bootasm.S, which calls bootmain().</span>
<span class="token comment">// bootasm.S has put the processor into protected 32-bit mode.</span>
<span class="token comment">// bootmain() loads an ELF kernel image from the disk starting at</span>
<span class="token comment">// sector 1 and then jumps to the kernel entry routine.</span>

<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">"types.h"</span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">"elf.h"</span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">"x86.h"</span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">"memlayout.h"</span></span>

<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token macro-name">SECTSIZE</span>  <span class="token expression"><span class="token number">512</span></span></span>

<span class="token keyword">void</span> <span class="token function">readseg</span><span class="token punctuation">(</span>uchar<span class="token operator">*</span><span class="token punctuation">,</span> uint<span class="token punctuation">,</span> uint<span class="token punctuation">)</span><span class="token punctuation">;</span>

<span class="token keyword">void</span>
<span class="token function">bootmain</span><span class="token punctuation">(</span><span class="token keyword">void</span><span class="token punctuation">)</span>
<span class="token punctuation">{</span>
  <span class="token keyword">struct</span> <span class="token class-name">elfhdr</span> <span class="token operator">*</span>elf<span class="token punctuation">;</span>
  <span class="token keyword">struct</span> <span class="token class-name">proghdr</span> <span class="token operator">*</span>ph<span class="token punctuation">,</span> <span class="token operator">*</span>eph<span class="token punctuation">;</span>
  <span class="token keyword">void</span> <span class="token punctuation">(</span><span class="token operator">*</span>entry<span class="token punctuation">)</span><span class="token punctuation">(</span><span class="token keyword">void</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  uchar<span class="token operator">*</span> pa<span class="token punctuation">;</span>

  elf <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token keyword">struct</span> <span class="token class-name">elfhdr</span><span class="token operator">*</span><span class="token punctuation">)</span><span class="token number">0x10000</span><span class="token punctuation">;</span>  <span class="token comment">// scratch space</span>

  <span class="token comment">// Read 1st page off disk</span>
  <span class="token function">readseg</span><span class="token punctuation">(</span><span class="token punctuation">(</span>uchar<span class="token operator">*</span><span class="token punctuation">)</span>elf<span class="token punctuation">,</span> <span class="token number">4096</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

  <span class="token comment">// Is this an ELF executable?</span>
  <span class="token keyword">if</span><span class="token punctuation">(</span>elf<span class="token operator">-></span>magic <span class="token operator">!=</span> ELF_MAGIC<span class="token punctuation">)</span>
    <span class="token keyword">return</span><span class="token punctuation">;</span>  <span class="token comment">// let bootasm.S handle error</span>

  <span class="token comment">// Load each program segment (ignores ph flags).</span>
  ph <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token keyword">struct</span> <span class="token class-name">proghdr</span><span class="token operator">*</span><span class="token punctuation">)</span><span class="token punctuation">(</span><span class="token punctuation">(</span>uchar<span class="token operator">*</span><span class="token punctuation">)</span>elf <span class="token operator">+</span> elf<span class="token operator">-></span>phoff<span class="token punctuation">)</span><span class="token punctuation">;</span>
  eph <span class="token operator">=</span> ph <span class="token operator">+</span> elf<span class="token operator">-></span>phnum<span class="token punctuation">;</span>
  <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token punctuation">;</span> ph <span class="token operator">&lt;</span> eph<span class="token punctuation">;</span> ph<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
    pa <span class="token operator">=</span> <span class="token punctuation">(</span>uchar<span class="token operator">*</span><span class="token punctuation">)</span>ph<span class="token operator">-></span>paddr<span class="token punctuation">;</span>
    <span class="token function">readseg</span><span class="token punctuation">(</span>pa<span class="token punctuation">,</span> ph<span class="token operator">-></span>filesz<span class="token punctuation">,</span> ph<span class="token operator">-></span>off<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">if</span><span class="token punctuation">(</span>ph<span class="token operator">-></span>memsz <span class="token operator">></span> ph<span class="token operator">-></span>filesz<span class="token punctuation">)</span>
      <span class="token function">stosb</span><span class="token punctuation">(</span>pa <span class="token operator">+</span> ph<span class="token operator">-></span>filesz<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> ph<span class="token operator">-></span>memsz <span class="token operator">-</span> ph<span class="token operator">-></span>filesz<span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span>

  <span class="token comment">// Call the entry point from the ELF header.</span>
  <span class="token comment">// Does not return!</span>
  entry <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token keyword">void</span><span class="token punctuation">(</span><span class="token operator">*</span><span class="token punctuation">)</span><span class="token punctuation">(</span><span class="token keyword">void</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">(</span>elf<span class="token operator">-></span>entry<span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token function">entry</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token keyword">void</span>
<span class="token function">waitdisk</span><span class="token punctuation">(</span><span class="token keyword">void</span><span class="token punctuation">)</span>
<span class="token punctuation">{</span>
  <span class="token comment">// Wait for disk ready.</span>
  <span class="token keyword">while</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token function">inb</span><span class="token punctuation">(</span><span class="token number">0x1F7</span><span class="token punctuation">)</span> <span class="token operator">&amp;</span> <span class="token number">0xC0</span><span class="token punctuation">)</span> <span class="token operator">!=</span> <span class="token number">0x40</span><span class="token punctuation">)</span>
    <span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token comment">// Read a single sector at offset into dst.</span>
<span class="token keyword">void</span>
<span class="token function">readsect</span><span class="token punctuation">(</span><span class="token keyword">void</span> <span class="token operator">*</span>dst<span class="token punctuation">,</span> uint offset<span class="token punctuation">)</span>
<span class="token punctuation">{</span>
  <span class="token comment">// Issue command.</span>
  <span class="token function">waitdisk</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token function">outb</span><span class="token punctuation">(</span><span class="token number">0x1F2</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>   <span class="token comment">// count = 1</span>
  <span class="token function">outb</span><span class="token punctuation">(</span><span class="token number">0x1F3</span><span class="token punctuation">,</span> offset<span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token function">outb</span><span class="token punctuation">(</span><span class="token number">0x1F4</span><span class="token punctuation">,</span> offset <span class="token operator">>></span> <span class="token number">8</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token function">outb</span><span class="token punctuation">(</span><span class="token number">0x1F5</span><span class="token punctuation">,</span> offset <span class="token operator">>></span> <span class="token number">16</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token function">outb</span><span class="token punctuation">(</span><span class="token number">0x1F6</span><span class="token punctuation">,</span> <span class="token punctuation">(</span>offset <span class="token operator">>></span> <span class="token number">24</span><span class="token punctuation">)</span> <span class="token operator">|</span> <span class="token number">0xE0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token function">outb</span><span class="token punctuation">(</span><span class="token number">0x1F7</span><span class="token punctuation">,</span> <span class="token number">0x20</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment">// cmd 0x20 - read sectors</span>

  <span class="token comment">// Read data.</span>
  <span class="token function">waitdisk</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token function">insl</span><span class="token punctuation">(</span><span class="token number">0x1F0</span><span class="token punctuation">,</span> dst<span class="token punctuation">,</span> SECTSIZE<span class="token operator">/</span><span class="token number">4</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token comment">// Read 'count' bytes at 'offset' from kernel into physical address 'pa'.</span>
<span class="token comment">// Might copy more than asked.</span>
<span class="token keyword">void</span>
<span class="token function">readseg</span><span class="token punctuation">(</span>uchar<span class="token operator">*</span> pa<span class="token punctuation">,</span> uint count<span class="token punctuation">,</span> uint offset<span class="token punctuation">)</span>
<span class="token punctuation">{</span>
  uchar<span class="token operator">*</span> epa<span class="token punctuation">;</span>

  epa <span class="token operator">=</span> pa <span class="token operator">+</span> count<span class="token punctuation">;</span>

  <span class="token comment">// Round down to sector boundary.</span>
  pa <span class="token operator">-=</span> offset <span class="token operator">%</span> SECTSIZE<span class="token punctuation">;</span>

  <span class="token comment">// Translate from bytes to sectors; kernel starts at sector 1.</span>
  offset <span class="token operator">=</span> <span class="token punctuation">(</span>offset <span class="token operator">/</span> SECTSIZE<span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">;</span>

  <span class="token comment">// If this is too slow, we could read lots of sectors at a time.</span>
  <span class="token comment">// We'd write more to memory than asked, but it doesn't matter --</span>
  <span class="token comment">// we load in increasing order.</span>
  <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token punctuation">;</span> pa <span class="token operator">&lt;</span> epa<span class="token punctuation">;</span> pa <span class="token operator">+=</span> SECTSIZE<span class="token punctuation">,</span> offset<span class="token operator">++</span><span class="token punctuation">)</span>
    <span class="token function">readsect</span><span class="token punctuation">(</span>pa<span class="token punctuation">,</span> offset<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span></code></pre></div>
<p>定義されている関数は以下の4つです。</p>
<ul>
<li>void bootmain(void)</li>
<li>void waitdisk(void)</li>
<li>void readsect(void *dst, uint offset)</li>
<li>void readsect(void *dst, uint offset)</li>
</ul>
<p>各関数の挙動については後で追っていきます。</p>
<h3 id="bootblockoの全体像" style="position:relative;"><a href="#bootblocko%E3%81%AE%E5%85%A8%E4%BD%93%E5%83%8F" aria-label="bootblockoの全体像 permalink" class="anchor before"><svg aria-hidden="true" focusable="false" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>bootblock.oの全体像</h3>
<p>続いて、<code class="language-text">bootasm.S</code>から<code class="language-text">bootasm.o</code>が生成され、先ほど生成した<code class="language-text">bootmain.o</code>とリンクされて<code class="language-text">bootblock.o</code>が生成されます。</p>
<p>以下は<code class="language-text">bootasm.S</code>です。</p>
<div class="gatsby-highlight" data-language="asm"><pre class="language-asm"><code class="language-asm">#include &quot;asm.h&quot;
#include &quot;memlayout.h&quot;
#include &quot;mmu.h&quot;

# Start the first CPU: switch to 32-bit protected mode, jump into C.
# The BIOS loads this code from the first sector of the hard disk into
# memory at physical address 0x7c00 and starts executing in real mode
# with %cs=0 %ip=7c00.

.code16                       # Assemble for 16-bit mode
.globl start
start:
  cli                         # BIOS enabled interrupts; disable

  # Zero data segment registers DS, ES, and SS.
  xorw    %ax,%ax             # Set %ax to zero
  movw    %ax,%ds             # -&gt; Data Segment
  movw    %ax,%es             # -&gt; Extra Segment
  movw    %ax,%ss             # -&gt; Stack Segment

  # Physical address line A20 is tied to zero so that the first PCs 
  # with 2 MB would run software that assumed 1 MB.  Undo that.
seta20.1:
  inb     $0x64,%al               # Wait for not busy
  testb   $0x2,%al
  jnz     seta20.1

  movb    $0xd1,%al               # 0xd1 -&gt; port 0x64
  outb    %al,$0x64

seta20.2:
  inb     $0x64,%al               # Wait for not busy
  testb   $0x2,%al
  jnz     seta20.2

  movb    $0xdf,%al               # 0xdf -&gt; port 0x60
  outb    %al,$0x60

  # Switch from real to protected mode.  Use a bootstrap GDT that makes
  # virtual addresses map directly to physical addresses so that the
  # effective memory map doesn&#39;t change during the transition.
  lgdt    gdtdesc
  movl    %cr0, %eax
  orl     $CR0_PE, %eax
  movl    %eax, %cr0

//PAGEBREAK!
  # Complete the transition to 32-bit protected mode by using a long jmp
  # to reload %cs and %eip.  The segment descriptors are set up with no
  # translation, so that the mapping is still the identity mapping.
  ljmp    $(SEG_KCODE&lt;&lt;3), $start32

.code32  # Tell assembler to generate 32-bit code now.
start32:
  # Set up the protected-mode data segment registers
  movw    $(SEG_KDATA&lt;&lt;3), %ax    # Our data segment selector
  movw    %ax, %ds                # -&gt; DS: Data Segment
  movw    %ax, %es                # -&gt; ES: Extra Segment
  movw    %ax, %ss                # -&gt; SS: Stack Segment
  movw    $0, %ax                 # Zero segments not ready for use
  movw    %ax, %fs                # -&gt; FS
  movw    %ax, %gs                # -&gt; GS

  # Set up the stack pointer and call into C.
  movl    $start, %esp
  call    bootmain

  # If bootmain returns (it shouldn&#39;t), trigger a Bochs
  # breakpoint if running under Bochs, then loop.
  movw    $0x8a00, %ax            # 0x8a00 -&gt; port 0x8a00
  movw    %ax, %dx
  outw    %ax, %dx
  movw    $0x8ae0, %ax            # 0x8ae0 -&gt; port 0x8a00
  outw    %ax, %dx
spin:
  jmp     spin

# Bootstrap GDT
.p2align 2                                # force 4 byte alignment
gdt:
  SEG_NULLASM                             # null seg
  SEG_ASM(STA_X|STA_R, 0x0, 0xffffffff)   # code seg
  SEG_ASM(STA_W, 0x0, 0xffffffff)         # data seg

gdtdesc:
  .word   (gdtdesc - gdt - 1)             # sizeof(gdt) - 1
  .long   gdt                             # address gdt</code></pre></div>
<p>中身を見る前に、ブートプログラムのリンクについて見てみます。</p>
<h3 id="ブートプログラムのリンク" style="position:relative;"><a href="#%E3%83%96%E3%83%BC%E3%83%88%E3%83%97%E3%83%AD%E3%82%B0%E3%83%A9%E3%83%A0%E3%81%AE%E3%83%AA%E3%83%B3%E3%82%AF" aria-label="ブートプログラムのリンク permalink" class="anchor before"><svg aria-hidden="true" focusable="false" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>ブートプログラムのリンク</h3>
<p>リンクは以下のコマンドで実行します。</p>
<div class="gatsby-highlight" data-language="bash"><pre class="language-bash"><code class="language-bash">ld -m elf_i386 -N -e start -Ttext 0x7C00 -o bootblock.o bootasm.o bootmain.o</code></pre></div>
<p><code class="language-text">ld</code>コマンドは、複数のバイナリを結合し、新たな実行プログラムをコンパイルすることができるコマンドです。</p>
<p>参考：<a href="https://kazmax.zpp.jp/cmd/l/ld.1.html" target="_blank" rel="nofollow noopener noreferrer">ld - コマンド (プログラム) の説明 - Linux コマンド集 一覧表</a></p>
<p>上記のコマンドでは、<code class="language-text">elf_i386</code>バイナリとしてリンクされます。</p>
<p>参考：<a href="https://unix.stackexchange.com/questions/471056/gnu-linker-differences-between-the-different-32bit-emulation-modes?rq=1" target="_blank" rel="nofollow noopener noreferrer">x86 - GNU Linker differences between the different 32bit emulation modes? - Unix &#x26; Linux Stack Exchange</a></p>
<p><code class="language-text">-N</code>オプションによってtextセクションとdataセクションは読み書き可能となり、<code class="language-text">start</code>シンボルがエントリポイントとして扱われます。</p>
<p>また、エントリポイントの開始アドレスは<code class="language-text">0x7C00</code>に定義されます。</p>
<p>これは、x86CPUの場合は、起動時にBIOSのPOST(Power On Self Test)が実行された後、MBRからブートプログラムを読み込んで<code class="language-text">0x7C00</code>に展開し、ブートセクタとします。</p>
<p>なぜこの位置に展開されるのかについては、以下の神記事に非常に詳しく書いてありました。</p>
<p>参考：<a href="https://www.glamenv-septzen.net/view/614" target="_blank" rel="nofollow noopener noreferrer">Assembler/なぜx86ではMBRが”0x7C00”にロードされるのか？(完全版) - Glamenv-Septzen.net</a></p>
<p>簡単にまとめると、ROM BIOSの必要とする最小メモリである32KBを開けておきたいというニーズと、0x0から0x3FFまでの範囲は割込みベクタとして予約されているため、結果としてブートセクタを32KBの末尾に置くことにしたとのことです。</p>
<p>そのため、ブートセクタの領域512Bと、MBRのbootstrap用のデータ/スタック領域として512Bを確保した結果、<code class="language-text">0x7C00(32KB - 1024B)</code>がブートセクタの先頭アドレスになったそうです。</p>
<p>このあたりは過去に読んだ自作OS本にはあまり詳しく書いていなかった(気がする)のでとても参考になりました。</p>
<p>これでブートプログラムが出来上がったので、まずは中身を見ていこうと思います。</p>
<h3 id="リアルモードとプロテクトモード" style="position:relative;"><a href="#%E3%83%AA%E3%82%A2%E3%83%AB%E3%83%A2%E3%83%BC%E3%83%89%E3%81%A8%E3%83%97%E3%83%AD%E3%83%86%E3%82%AF%E3%83%88%E3%83%A2%E3%83%BC%E3%83%89" aria-label="リアルモードとプロテクトモード permalink" class="anchor before"><svg aria-hidden="true" focusable="false" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>リアルモードとプロテクトモード</h3>
<p><code class="language-text">x86CPU</code>では、起動時に<code class="language-text">Intel 8086</code>とソフトウェア互換のある「リアルモード」で起動します。</p>
<p><code class="language-text">Intel 8086</code>は16bitです。</p>
<p>そのため、リアルモードは16bitで動作する状態になります。</p>
<p>参考：<a href="https://en.wikipedia.org/wiki/Intel_8086" target="_blank" rel="nofollow noopener noreferrer">Intel 8086 - Wikipedia</a></p>
<p>ここから、32bitに移行するための処理を追っていきます。</p>
<p>リアルモードで動作する処理は以下の部分です。</p>
<div class="gatsby-highlight" data-language="assembly"><pre class="language-assembly"><code class="language-assembly">#include &quot;asm.h&quot;
#include &quot;memlayout.h&quot;
#include &quot;mmu.h&quot;

# Start the first CPU: switch to 32-bit protected mode, jump into C.
# The BIOS loads this code from the first sector of the hard disk into
# memory at physical address 0x7c00 and starts executing in real mode
# with %cs=0 %ip=7c00.

.code16                       # Assemble for 16-bit mode
.globl start
start:
  cli                         # BIOS enabled interrupts; disable

  # Zero data segment registers DS, ES, and SS.
  xorw    %ax,%ax             # Set %ax to zero
  movw    %ax,%ds             # -&gt; Data Segment
  movw    %ax,%es             # -&gt; Extra Segment
  movw    %ax,%ss             # -&gt; Stack Segment

  # Physical address line A20 is tied to zero so that the first PCs 
  # with 2 MB would run software that assumed 1 MB.  Undo that.
seta20.1:
  inb     $0x64,%al               # Wait for not busy
  testb   $0x2,%al
  jnz     seta20.1

  movb    $0xd1,%al               # 0xd1 -&gt; port 0x64
  outb    %al,$0x64

seta20.2:
  inb     $0x64,%al               # Wait for not busy
  testb   $0x2,%al
  jnz     seta20.2

  movb    $0xdf,%al               # 0xdf -&gt; port 0x60
  outb    %al,$0x60

  # Switch from real to protected mode.  Use a bootstrap GDT that makes
  # virtual addresses map directly to physical addresses so that the
  # effective memory map doesn&#39;t change during the transition.
  lgdt    gdtdesc
  movl    %cr0, %eax
  orl     $CR0_PE, %eax
  movl    %eax, %cr0

//PAGEBREAK!
  # Complete the transition to 32-bit protected mode by using a long jmp
  # to reload %cs and %eip.  The segment descriptors are set up with no
  # translation, so that the mapping is still the identity mapping.
  ljmp    $(SEG_KCODE&lt;&lt;3), $start32

.code32  # Tell assembler to generate 32-bit code now.
start32:
{{ 省略 }}</code></pre></div>
<h3 id="リアルモードで起動する" style="position:relative;"><a href="#%E3%83%AA%E3%82%A2%E3%83%AB%E3%83%A2%E3%83%BC%E3%83%89%E3%81%A7%E8%B5%B7%E5%8B%95%E3%81%99%E3%82%8B" aria-label="リアルモードで起動する permalink" class="anchor before"><svg aria-hidden="true" focusable="false" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>リアルモードで起動する</h3>
<p>以下では、<code class="language-text">.code16</code>を先頭に書くことで、コードが16bitで実行される想定となるようにアセンブラに指示をしています。</p>
<p><code class="language-text">start</code>セクションは、先ほどエントリポイントとしてリンクされたシンボルです。</p>
<div class="gatsby-highlight" data-language="assembly"><pre class="language-assembly"><code class="language-assembly">.code16                       # Assemble for 16-bit mode
.globl start
start:
  cli                         # BIOS enabled interrupts; disable

  # Zero data segment registers DS, ES, and SS.
  xorw    %ax,%ax             # Set %ax to zero
  movw    %ax,%ds             # -&gt; Data Segment
  movw    %ax,%es             # -&gt; Extra Segment
  movw    %ax,%ss             # -&gt; Stack Segment</code></pre></div>
<p>参考：<a href="https://stackoverflow.com/questions/32395542/objdump-of-code16-and-code32-x86-assembly" target="_blank" rel="nofollow noopener noreferrer">Objdump of .code16 and .code32 x86 assembly - Stack Overflow</a></p>
<h3 id="cliとstiでcpu割込みを禁止" style="position:relative;"><a href="#cli%E3%81%A8sti%E3%81%A7cpu%E5%89%B2%E8%BE%BC%E3%81%BF%E3%82%92%E7%A6%81%E6%AD%A2" aria-label="cliとstiでcpu割込みを禁止 permalink" class="anchor before"><svg aria-hidden="true" focusable="false" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>cliとstiでCPU割込みを禁止</h3>
<p><code class="language-text">cli</code>は、CPUの割込みを禁止する命令です。</p>
<p><code class="language-text">cli</code>が呼び出されてから、<code class="language-text">sti</code>命令が呼び出されるまでの区間の処理は、CPUの割込みが禁止されます。(正確にはCPUからの割込み要求は発生するが無視される)</p>
<p>参考：<a href="https://c9x.me/x86/html/file_module_x86_id_31.html" target="_blank" rel="nofollow noopener noreferrer">CLI : Clear Interrupt Flag (x86 Instruction Set Reference)</a></p>
<p>これは、BIOSに設定された割込みが有効化されたままだと、ブートプログラムの処理が正しく動作しなくなるためです。</p>
<p>そのため、ブートプログラム側でスタックポインタや割込み設定を行っている間は、割込みを無効化しておく必要があります。</p>
<h3 id="セグメントレジスタの初期化" style="position:relative;"><a href="#%E3%82%BB%E3%82%B0%E3%83%A1%E3%83%B3%E3%83%88%E3%83%AC%E3%82%B8%E3%82%B9%E3%82%BF%E3%81%AE%E5%88%9D%E6%9C%9F%E5%8C%96" aria-label="セグメントレジスタの初期化 permalink" class="anchor before"><svg aria-hidden="true" focusable="false" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>セグメントレジスタの初期化</h3>
<p>次の4行では、AXレジスタ、DSレジスタ、ESレジスタ、SSレジスタをそれぞれ<code class="language-text">0x0000</code>に初期化しています。</p>
<p>AXレジスタはアキュムレータですが、他の3つのレジスタはセグメントレジスタです。</p>
<p>参考：<a href="https://en.wikipedia.org/wiki/Intel_8086" target="_blank" rel="nofollow noopener noreferrer">Intel 8086 - Wikipedia</a></p>
<p>参考：<a href="https://qiita.com/timwata/items/e7b7a18cc80b31fd940a" target="_blank" rel="nofollow noopener noreferrer">Intel 8086 CPU 基礎 - Qiita</a></p>
<p>ここでは、BIOSに設定されたセグメントレジスタの値を初期化しています。</p>
<p>一応各セグメントレジスタの用途について簡単に書いておきます。</p>
<table>
<thead>
<tr>
<th align="center">レジスタ</th>
<th align="center">用途</th>
</tr>
</thead>
<tbody>
<tr>
<td align="center">DSレジスタ</td>
<td align="center">データ用のデフォルトセグメントレジスタ</td>
</tr>
<tr>
<td align="center">ESレジスタ</td>
<td align="center">データ用のセグメントレジスタ<br />通常はDSレジスタを使用</td>
</tr>
<tr>
<td align="center">SSレジスタ</td>
<td align="center">スタック用のセグメントレジスタで、SPやBPによるメモリ参照時に使用</td>
</tr>
<tr>
<td align="center">CSレジスタ</td>
<td align="center">コード用のセグメントレジスタ<br />命令ポインタ(IP)はCSレジスタを使用</td>
</tr>
</tbody>
</table>
<p>参考：<a href="http://www.tamasoft.co.jp/lasm/help/lasm1to2.htm" target="_blank" rel="nofollow noopener noreferrer">8086 のレジスタ</a></p>
<h3 id="a20-lineの有効化" style="position:relative;"><a href="#a20-line%E3%81%AE%E6%9C%89%E5%8A%B9%E5%8C%96" aria-label="a20 lineの有効化 permalink" class="anchor before"><svg aria-hidden="true" focusable="false" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>A20 Lineの有効化</h3>
<p><code class="language-text">Intel 8086</code>では、後方互換のためにデフォルトでA20 Line(メモリアクセスの21番目のbit)が無効化されています。</p>
<p>そのため、最大2MBのメモリ領域にアクセスするためには、A20 Lineを有効化する必要があります。</p>
<p>A20 Lineは初めはKBC(キーボードコントローラ)に接続されています。</p>
<p>KBCとは、キーボードからの入力をCPUに伝えるための機構です。</p>
<p>KBCは、キーボードからシリアル通信で受け取った情報を一度バッファに格納し、KBCの制御コマンドか、CPUに転送する入力データかをチェックします。</p>
<p>CPUに転送するデータの場合は<code class="language-text">0x60</code>、制御コマンドの場合は<code class="language-text">0x64</code>のポートからデータが転送されます。</p>
<p>ここで、以下のコードではそれぞれ、KBCのバッファに未処理の入力がない状態を確認してから、<code class="language-text">0x60</code>と<code class="language-text">0x64</code>のポートにそれぞれ制御コマンドを送信することで、A20を有効化します。</p>
<div class="gatsby-highlight" data-language="assembly"><pre class="language-assembly"><code class="language-assembly">  # Physical address line A20 is tied to zero so that the first PCs 
  # with 2 MB would run software that assumed 1 MB.  Undo that.
seta20.1:
  inb     $0x64,%al               # Wait for not busy
  testb   $0x2,%al
  jnz     seta20.1

  movb    $0xd1,%al               # 0xd1 -&gt; port 0x64
  outb    %al,$0x64

seta20.2:
  inb     $0x64,%al               # Wait for not busy
  testb   $0x2,%al
  jnz     seta20.2

  movb    $0xdf,%al               # 0xdf -&gt; port 0x60
  outb    %al,$0x60</code></pre></div>
<p>上記の例では、制御コマンド<code class="language-text">0xd1</code>をポート<code class="language-text">0x64</code>に送信した後、<code class="language-text">0xdf</code>がポート<code class="language-text">0x60</code>に送信され、A20が有効になります。</p>
<p>参考：<a href="https://wiki.osdev.org/A20_Line" target="_blank" rel="nofollow noopener noreferrer">A20 Line - OSDev Wiki</a></p>
<p>参考：<a href="https://cstmize.hatenablog.jp/entry/2019/06/11/A20_gate%E3%81%A8keyboard_controller%E3%81%A8%E3%81%AE%E3%82%84%E3%82%8A%E3%81%A8%E3%82%8A%28xv6%E3%82%92%E4%BE%8B%E3%81%AB%E3%81%97%E3%81%A6%29" target="_blank" rel="nofollow noopener noreferrer">A20 gateとkeyboard controller(xv6を例にして) - 私のひらめき日記</a></p>
<p>参考：<a href="https://stackoverflow.com/questions/15768683/the-a20-line-with-jos" target="_blank" rel="nofollow noopener noreferrer">assembly - The A20 Line with JOS - Stack Overflow</a></p>
<h3 id="プロテクトモードへの移行" style="position:relative;"><a href="#%E3%83%97%E3%83%AD%E3%83%86%E3%82%AF%E3%83%88%E3%83%A2%E3%83%BC%E3%83%89%E3%81%B8%E3%81%AE%E7%A7%BB%E8%A1%8C" aria-label="プロテクトモードへの移行 permalink" class="anchor before"><svg aria-hidden="true" focusable="false" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>プロテクトモードへの移行</h3>
<p>ここからプログラムの操作はプロテクトモードに移行します。</p>
<p>プロテクトモードは「保護」リアルモードとは異なり、メモリ空間が保護されます。</p>
<p>つまり、プロテクトモードではプログラムは許可されたメモリ空間にのみアクセスすることが可能となります。</p>
<p>このため、リアルモードからプロテクトモードに移行する際には、ロードするカーネルがアクセス可能なメモリ空間を事前に定義する必要があります。</p>
<div class="gatsby-highlight" data-language="assembly"><pre class="language-assembly"><code class="language-assembly">  # Switch from real to protected mode.  Use a bootstrap GDT that makes
  # virtual addresses map directly to physical addresses so that the
  # effective memory map doesn&#39;t change during the transition.
  lgdt    gdtdesc
  movl    %cr0, %eax
  orl     $CR0_PE, %eax
  movl    %eax, %cr0

//PAGEBREAK!
  # Complete the transition to 32-bit protected mode by using a long jmp
  # to reload %cs and %eip.  The segment descriptors are set up with no
  # translation, so that the mapping is still the identity mapping.
  ljmp    $(SEG_KCODE&lt;&lt;3), $start32

.code32  # Tell assembler to generate 32-bit code now.
start32:</code></pre></div>
<p>プロテクトモードへの移行自体は以下の行で行っています。</p>
<div class="gatsby-highlight" data-language="assembly"><pre class="language-assembly"><code class="language-assembly">movl    %cr0, %eax
orl     $CR0_PE, %eax
movl    %eax, %cr0</code></pre></div>
<p>x86CPUでは、プロテクトモードを有効化するためにコントロールレジスタのPEフラグを1にする必要があります。</p>
<p>上記のアセンブリコードでは、<code class="language-text">or</code>演算を用いてコントロールレジスタのPEフラグを1に設定しています。</p>
<p>これでプロテクトモードへの移行が完了します。</p>
<p>※GDTの初期化を先に完了させておく必要があります。</p>
<p>参考：<a href="https://en.wikipedia.org/wiki/Control_register" target="_blank" rel="nofollow noopener noreferrer">Control register - Wikipedia</a></p>
<h3 id="プロテクトモードでのメモリアドレス参照" style="position:relative;"><a href="#%E3%83%97%E3%83%AD%E3%83%86%E3%82%AF%E3%83%88%E3%83%A2%E3%83%BC%E3%83%89%E3%81%A7%E3%81%AE%E3%83%A1%E3%83%A2%E3%83%AA%E3%82%A2%E3%83%89%E3%83%AC%E3%82%B9%E5%8F%82%E7%85%A7" aria-label="プロテクトモードでのメモリアドレス参照 permalink" class="anchor before"><svg aria-hidden="true" focusable="false" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>プロテクトモードでのメモリアドレス参照</h3>
<p>プロテクトモードでは、メモリアドレスの参照のためにGDT(グローバルディスクリプタテーブル)が使用されます。</p>
<p>GDT周りの機構については長くなったので別の記事にメモ書きとしてまとめました。</p>
<p>参考：<a href="/linux-got-plt">x86CPUのメモリ保護機構に関するメモ書き(GDTとLDT)</a></p>
<h3 id="lgdt-gdtdesc" style="position:relative;"><a href="#lgdt-gdtdesc" aria-label="lgdt gdtdesc permalink" class="anchor before"><svg aria-hidden="true" focusable="false" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>lgdt gdtdesc</h3>
<p>まず、<code class="language-text">lgdt</code>命令はGDTのデータ構造をGDTRに登録するための命令です。</p>
<p>ここに格納している<code class="language-text">gdtdesc</code>は、<code class="language-text">bootasm.S</code>内で定義された以下のラベルです。</p>
<div class="gatsby-highlight" data-language="assembly"><pre class="language-assembly"><code class="language-assembly"># Bootstrap GDT
.p2align 2                                # force 4 byte alignment
gdt:
  SEG_NULLASM                             # null seg
  SEG_ASM(STA_X|STA_R, 0x0, 0xffffffff)   # code seg
  SEG_ASM(STA_W, 0x0, 0xffffffff)         # data seg

gdtdesc:
  .word   (gdtdesc - gdt - 1)             # sizeof(gdt) - 1
  .long   gdt                             # address gdt</code></pre></div>
<p><code class="language-text">.p2align 2</code>は、この直後の命令やデータを4バイト境界に強制的に配置させます。</p>
<p>これは、4の倍数のアドレスを開始点としてデータを配置することを意味します。</p>
<p>参考：<a href="https://stackoverflow.com/questions/2846914/what-is-meant-by-memory-is-8-bytes-aligned" target="_blank" rel="nofollow noopener noreferrer">c - What is meant by “memory is 8 bytes aligned”? - Stack Overflow</a></p>
<p>次の行では、<code class="language-text">SEG_NULLASM</code>マクロなどが配置されている行に<code class="language-text">gtd</code>ラベルを付けています。</p>
<p>これらのマクロは、<code class="language-text">asm.h</code>で定義されている以下のマクロです。</p>
<div class="gatsby-highlight" data-language="assembly"><pre class="language-assembly"><code class="language-assembly">//
// assembler macros to create x86 segments
//

#define SEG_NULLASM                                             \
        .word 0, 0;                                             \
        .byte 0, 0, 0, 0

// The 0xC0 means the limit is in 4096-byte units
// and (for executable segments) 32-bit mode.
#define SEG_ASM(type,base,lim)                                  \
        .word (((lim) &gt;&gt; 12) &amp; 0xffff), ((base) &amp; 0xffff);      \
        .byte (((base) &gt;&gt; 16) &amp; 0xff), (0x90 | (type)),         \
                (0xC0 | (((lim) &gt;&gt; 28) &amp; 0xf)), (((base) &gt;&gt; 24) &amp; 0xff)

#define STA_X     0x8       // Executable segment
#define STA_W     0x2       // Writeable (non-executable segments)
#define STA_R     0x2       // Readable (executable segments)</code></pre></div>
<p>x86CPUにおけるGDTは、基本的には8バイトのディスクリプタをいくつも並べた構造になっています。</p>
<p>参考：<a href="https://en.wikipedia.org/wiki/Global_Descriptor_Table" target="_blank" rel="nofollow noopener noreferrer">Global Descriptor Table - Wikipedia</a></p>
<p>参考：<a href="https://amzn.to/3qXYsZX" target="_blank" rel="nofollow noopener noreferrer">ゼロからのOS自作入門</a></p>
<p>以下は、<a href="https://amzn.to/3qZSCY7" target="_blank" rel="nofollow noopener noreferrer">30日でできる! OS自作入門</a>で紹介されていたディスクリプタの構造体です。</p>
<p>こちらの方がxv6OSのコードよりもわかりやすかったので貼っておきます。</p>
<div class="gatsby-highlight" data-language="c"><pre class="language-c"><code class="language-c"><span class="token keyword">struct</span> <span class="token class-name">SEGMENT_DESCRIPTOR</span><span class="token punctuation">{</span>
    <span class="token keyword">short</span> limit_low<span class="token punctuation">,</span> base_low<span class="token punctuation">;</span>
    <span class="token keyword">char</span> base_mid<span class="token punctuation">,</span> access_right<span class="token punctuation">;</span>
    <span class="token keyword">char</span> limit_high<span class="token punctuation">,</span> base_high<span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span></code></pre></div>
<p>参考：<a href="https://amzn.to/3qZSCY7" target="_blank" rel="nofollow noopener noreferrer">30日でできる! OS自作入門</a></p>
<p>GDTの先頭(1つ目のディスクリプタ)には、すべての値が0に設定されたヌルディスクリプタを配置します。</p>
<p>これはシステムからは参照されることはありません。</p>
<p>ヌルディスクリプタはセグメントレジスタを無効化するために使用されます。</p>
<p>参考：<a href="https://stackoverflow.com/questions/37861691/why-x86-processor-need-a-null-descriptor-in-gdt" target="_blank" rel="nofollow noopener noreferrer">Why x86 processor need a NULL descriptor in GDT? - Stack Overflow</a></p>
<p>2番目のディスクリプタはコードセグメント、3番目のディスクリプタはデータセグメントのディスクリプタを定義しています。</p>
<p>コードセグメントは読み取りと実行、データセグメントは書き込み権限が付与されています。</p>
<p>最後に、このマクロで作成したGDTのアドレスを使用して、<code class="language-text">lgdt gdtdesc</code>命令によってGDTRを初期化します。</p>
<p>GDTRには48bitの値を格納します。</p>
<p>上位32bitには、GDTの先頭アドレス(gdtラベル)が格納されます。</p>
<p>下位16bitには、リミット値(GDTのエントリ数)が格納されます。</p>
<p>参考：<a href="https://yz2cm.hatenadiary.org/entry/20140502/1399006500" target="_blank" rel="nofollow noopener noreferrer">GDTR（Global Descriptor Table Register） - ゆずさん研究所</a></p>
<p>プログラムがLDTなどのディスクリプタを利用する際には、GDTRにセットされた先頭アドレスからのオフセットとして参照されることになります。</p>
<p>これでGDTRの初期化が完了しました。</p>
<p>参考：<a href="https://stackoverflow.com/questions/67901342/why-in-xv6-theres-sizeofgdt-1-in-gdtdesc" target="_blank" rel="nofollow noopener noreferrer">assembly - Why in xv6 there’s sizeof(gdt)-1 in gdtdesc - Stack Overflow</a></p>
<p>参考：<a href="https://jupiteroak.hatenablog.com/entry/2021/12/10/073000" target="_blank" rel="nofollow noopener noreferrer">OS起動編⑮-2 entryother.S (Unix xv6を読む～OSコードリーディング～) - 野良プログラマーのCS日記</a></p>
<h3 id="32bitモードの開始" style="position:relative;"><a href="#32bit%E3%83%A2%E3%83%BC%E3%83%89%E3%81%AE%E9%96%8B%E5%A7%8B" aria-label="32bitモードの開始 permalink" class="anchor before"><svg aria-hidden="true" focusable="false" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>32bitモードの開始</h3>
<p>GDTRの初期化とプロテクトモードへの移行が完了したため、ここからは32bitモードで動作することになります。</p>
<div class="gatsby-highlight" data-language="assembly"><pre class="language-assembly"><code class="language-assembly">//PAGEBREAK!
  # Complete the transition to 32-bit protected mode by using a long jmp
  # to reload %cs and %eip.  The segment descriptors are set up with no
  # translation, so that the mapping is still the identity mapping.
  ljmp    $(SEG_KCODE&lt;&lt;3), $start32

.code32  # Tell assembler to generate 32-bit code now.
start32:</code></pre></div>
<p><code class="language-text">ljmp</code>命令は第1オペランドにセグメントセレクタをとり、第2オペランドにオフセットアドレス(<code class="language-text">start32</code>ラベル)を与えることで、セレクタに対応するセグメントベース+オフセットのアドレスにジャンプする命令です。</p>
<p><code class="language-text">SEG_KCODE</code>は<code class="language-text">mmu.h</code>内で以下のように定義されています。</p>
<div class="gatsby-highlight" data-language="c"><pre class="language-c"><code class="language-c"><span class="token comment">// various segment selectors.</span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token macro-name">SEG_KCODE</span> <span class="token expression"><span class="token number">1</span>  </span><span class="token comment">// kernel code</span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token macro-name">SEG_KDATA</span> <span class="token expression"><span class="token number">2</span>  </span><span class="token comment">// kernel data+stack</span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token macro-name">SEG_UCODE</span> <span class="token expression"><span class="token number">3</span>  </span><span class="token comment">// user code</span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token macro-name">SEG_UDATA</span> <span class="token expression"><span class="token number">4</span>  </span><span class="token comment">// user data+stack</span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token macro-name">SEG_TSS</span>   <span class="token expression"><span class="token number">5</span>  </span><span class="token comment">// this process's task state</span></span></code></pre></div>
<p>上記より、<code class="language-text">$(SEG_KCODE&lt;&lt;3)</code>が定義するセグメントセレクタは、<code class="language-text">0b1000</code>となります。</p>
<p>これは、GDTの2つ目のセグメントであるコードセグメントを指します。</p>
<p>セグメントセレクタは、以下のページの通り16bitで構成され、上位13bitにはディスクリプタのインデックス(GDTの先頭からのインデックス)が定義され、下位3bitにはテーブルインジゲータ(TI)と要求特権レベル(RPL)が定義されます。</p>
<p>参考：<a href="https://yz2cm.hatenadiary.org/entry/20140502/1399012324" target="_blank" rel="nofollow noopener noreferrer">セグメント・セレクタ - ゆずさん研究所</a></p>
<p>TIが0の場合、GDTを参照します。(1の場合はLDTを参照)</p>
<p>また、RPLが0の場合は、特権アクセスを意味します。</p>
<p>ここで、<code class="language-text">$(SEG_KCODE&lt;&lt;3)</code>が定義するセグメントセレクタ<code class="language-text">0b1000</code>は、インデックスが1、TIが0、RPLが0と定義されたセグメントレジスタになります。</p>
<h3 id="なぜljmp命令を使用するのか" style="position:relative;"><a href="#%E3%81%AA%E3%81%9Cljmp%E5%91%BD%E4%BB%A4%E3%82%92%E4%BD%BF%E7%94%A8%E3%81%99%E3%82%8B%E3%81%AE%E3%81%8B" aria-label="なぜljmp命令を使用するのか permalink" class="anchor before"><svg aria-hidden="true" focusable="false" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>なぜljmp命令を使用するのか</h3>
<p>このコードには少し違和感がありました。</p>
<p><code class="language-text">%cr0</code>の設定が完了してプロテクトモードに移行するところまで処理を進めた場合、わざわざ<code class="language-text">ljmp</code>命令を呼び出さなくても<code class="language-text">start32</code>の処理が呼び出されるはずです。</p>
<div class="gatsby-highlight" data-language="assembly"><pre class="language-assembly"><code class="language-assembly">  lgdt    gdtdesc
  movl    %cr0, %eax
  orl     $CR0_PE, %eax
  movl    %eax, %cr0
  ljmp    $(SEG_KCODE&lt;&lt;3), $start32

.code32  # Tell assembler to generate 32-bit code now.
start32:
{{ 省略 }}</code></pre></div>
<p>ここでわざわざ<code class="language-text">ljmp</code>命令を使用しているのは、リアルモードで動作していた際にCPUが高速化のためにメモリから先読みした命令を破棄するためです。</p>
<p>CPUには命令を高速に実行するためにパイプラインという仕組みがあり、これによって次の命令を先読みしています。</p>
<p>しかし、プロテクトモードに移行するとリアルモードとは機械語の解釈が変わるため、これをリセットする必要がありまし。</p>
<p><code class="language-text">ljmp</code>命令を呼び出すことで、<code class="language-text">cs</code>レジスタや<code class="language-text">eip</code>レジスタの値がリロードされます。</p>
<h3 id="プロテクトモード移行後の設定" style="position:relative;"><a href="#%E3%83%97%E3%83%AD%E3%83%86%E3%82%AF%E3%83%88%E3%83%A2%E3%83%BC%E3%83%89%E7%A7%BB%E8%A1%8C%E5%BE%8C%E3%81%AE%E8%A8%AD%E5%AE%9A" aria-label="プロテクトモード移行後の設定 permalink" class="anchor before"><svg aria-hidden="true" focusable="false" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>プロテクトモード移行後の設定</h3>
<p>あと少しで<code class="language-text">bootasm.S</code>の処理をすべて追うことができます。</p>
<p>最後に見るのは以下の挙動です。</p>
<div class="gatsby-highlight" data-language="assembly"><pre class="language-assembly"><code class="language-assembly">.code32  # Tell assembler to generate 32-bit code now.
start32:
  # Set up the protected-mode data segment registers
  movw    $(SEG_KDATA&lt;&lt;3), %ax    # Our data segment selector
  movw    %ax, %ds                # -&gt; DS: Data Segment
  movw    %ax, %es                # -&gt; ES: Extra Segment
  movw    %ax, %ss                # -&gt; SS: Stack Segment
  movw    $0, %ax                 # Zero segments not ready for use
  movw    %ax, %fs                # -&gt; FS
  movw    %ax, %gs                # -&gt; GS

  # Set up the stack pointer and call into C.
  movl    $start, %esp
  call    bootmain

  # If bootmain returns (it shouldn&#39;t), trigger a Bochs
  # breakpoint if running under Bochs, then loop.
  movw    $0x8a00, %ax            # 0x8a00 -&gt; port 0x8a00
  movw    %ax, %dx
  outw    %ax, %dx
  movw    $0x8ae0, %ax            # 0x8ae0 -&gt; port 0x8a00
  outw    %ax, %dx
spin:
  jmp     spin</code></pre></div>
<h3 id="セグメントレジスタの初期化-1" style="position:relative;"><a href="#%E3%82%BB%E3%82%B0%E3%83%A1%E3%83%B3%E3%83%88%E3%83%AC%E3%82%B8%E3%82%B9%E3%82%BF%E3%81%AE%E5%88%9D%E6%9C%9F%E5%8C%96-1" aria-label="セグメントレジスタの初期化 1 permalink" class="anchor before"><svg aria-hidden="true" focusable="false" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>セグメントレジスタの初期化</h3>
<p>ここでは、CS以外のセグメントレジスタの初期化を行っています。</p>
<p>リアルモードからプロテクトモードに移行したことで、セグメントセレクタの用法が変わりました。</p>
<p>具体的には、リアルモードではメモリアドレスを参照する場合に、セグメント部を16倍してオフセットに加算する方式を取っていたものが、プロテクトモードではセグメントディスクリプタの参照に変わります。</p>
<p>参考：<a href="https://atmarkit.itmedia.co.jp/icd/root/02/5785802.html" target="_blank" rel="nofollow noopener noreferrer">Insider’s Computer Dictionary：8086 とは？ - ＠IT</a></p>
<p>そのため、プロテクトモードではセグメントレジスタにはセグメントセレクタを格納する必要があります。</p>
<div class="gatsby-highlight" data-language="assembly"><pre class="language-assembly"><code class="language-assembly">start32:
  # Set up the protected-mode data segment registers
  movw    $(SEG_KDATA&lt;&lt;3), %ax    # Our data segment selector
  movw    %ax, %ds                # -&gt; DS: Data Segment
  movw    %ax, %es                # -&gt; ES: Extra Segment
  movw    %ax, %ss                # -&gt; SS: Stack Segment
  
  movw    $0, %ax                 # Zero segments not ready for use
  movw    %ax, %fs                # -&gt; FS
  movw    %ax, %gs                # -&gt; GS</code></pre></div>
<p>セグメントセレクタは<code class="language-text">$(SEG_KDATA&lt;&lt;3)</code>で設定されます。</p>
<p><code class="language-text">SEG_KDATA</code>は<code class="language-text">mmu.h</code>内で2と定義されていました。</p>
<p>つまり、<code class="language-text">$(SEG_KDATA&lt;&lt;3)</code>は<code class="language-text">0b1000</code>となります。</p>
<p>これは、GDTの3番目に定義したセグメントディスクリプタ<code class="language-text">SEG_ASM(STA_W, 0x0, 0xffffffff)</code>を指定するセレクタになります。</p>
<p>これらの値を用いて、DS、ES、SSの各セグメントレジスタを初期化しています。</p>
<p>また、FSとGSには0を格納しています。</p>
<p>セグメントセレクタが0の場合、セグメントレジスタは無効化されます。</p>
<h3 id="bootmaincの呼び出し" style="position:relative;"><a href="#bootmainc%E3%81%AE%E5%91%BC%E3%81%B3%E5%87%BA%E3%81%97" aria-label="bootmaincの呼び出し permalink" class="anchor before"><svg aria-hidden="true" focusable="false" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>bootmain.cの呼び出し</h3>
<p>ここからは、<code class="language-text">bootmain.c</code>に処理が移行します。</p>
<p><code class="language-text">$start</code>は初めに見た通り、<code class="language-text">0x7C00</code>に配置されています。</p>
<p>つまり、スタックポインタ(スタックを積むベースのアドレス)は<code class="language-text">0x7C00</code>になるわけですね。</p>
<div class="gatsby-highlight" data-language="assembly"><pre class="language-assembly"><code class="language-assembly"># Set up the stack pointer and call into C.
movl    $start, %esp
call    bootmain</code></pre></div>
<p>上記より、今までの理解を図にするとこのようになるかと思います。(違ってたらごめんなさい)</p>
<p><img src="https://yukituna.com/wp-content/uploads/2022/01/image-15.png" alt="https://yukituna.com/wp-content/uploads/2022/01/image-15.png"></p>
<p>ちなみに以下は<code class="language-text">bootmain.c</code>がReturnされた後の処理となるので今回は割愛します。</p>
<div class="gatsby-highlight" data-language="assembly"><pre class="language-assembly"><code class="language-assembly">  # If bootmain returns (it shouldn&#39;t), trigger a Bochs
  # breakpoint if running under Bochs, then loop.
  movw    $0x8a00, %ax            # 0x8a00 -&gt; port 0x8a00
  movw    %ax, %dx
  outw    %ax, %dx
  movw    $0x8ae0, %ax            # 0x8ae0 -&gt; port 0x8a00
  outw    %ax, %dx
spin:
  jmp     spin</code></pre></div>
<h3 id="カーネルのロード" style="position:relative;"><a href="#%E3%82%AB%E3%83%BC%E3%83%8D%E3%83%AB%E3%81%AE%E3%83%AD%E3%83%BC%E3%83%89" aria-label="カーネルのロード permalink" class="anchor before"><svg aria-hidden="true" focusable="false" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>カーネルのロード</h3>
<p>ようやくプロテクトモードへの移行も完了し、処理が<code class="language-text">bootmain.c</code>に切り替わりました。</p>
<p><code class="language-text">bootmain.c</code>には、以下の4つの関数が定義されていますす。</p>
<ul>
<li>void bootmain(void)</li>
<li>void waitdisk(void)</li>
<li>void readsect(void *dst, uint offset)</li>
<li>void readsect(void *dst, uint offset)</li>
</ul>
<p>ここからは<code class="language-text">bootmain.c</code>の挙動について追っていきます。</p>
<h3 id="ディスクからelfカーネルイメージをロードする" style="position:relative;"><a href="#%E3%83%87%E3%82%A3%E3%82%B9%E3%82%AF%E3%81%8B%E3%82%89elf%E3%82%AB%E3%83%BC%E3%83%8D%E3%83%AB%E3%82%A4%E3%83%A1%E3%83%BC%E3%82%B8%E3%82%92%E3%83%AD%E3%83%BC%E3%83%89%E3%81%99%E3%82%8B" aria-label="ディスクからelfカーネルイメージをロードする permalink" class="anchor before"><svg aria-hidden="true" focusable="false" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>ディスクからELFカーネルイメージをロードする</h3>
<p><code class="language-text">bootmain()</code>は、ディスクからELFカーネルイメージをロードするための関数です。</p>
<p>先頭から順に見ていきます。</p>
<div class="gatsby-highlight" data-language="c"><pre class="language-c"><code class="language-c"><span class="token keyword">void</span> <span class="token function">bootmain</span><span class="token punctuation">(</span><span class="token keyword">void</span><span class="token punctuation">)</span>
<span class="token punctuation">{</span>
  <span class="token keyword">struct</span> <span class="token class-name">elfhdr</span> <span class="token operator">*</span>elf<span class="token punctuation">;</span>
  <span class="token keyword">struct</span> <span class="token class-name">proghdr</span> <span class="token operator">*</span>ph<span class="token punctuation">,</span> <span class="token operator">*</span>eph<span class="token punctuation">;</span>
  <span class="token keyword">void</span> <span class="token punctuation">(</span><span class="token operator">*</span>entry<span class="token punctuation">)</span><span class="token punctuation">(</span><span class="token keyword">void</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  uchar<span class="token operator">*</span> pa<span class="token punctuation">;</span>

  elf <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token keyword">struct</span> <span class="token class-name">elfhdr</span><span class="token operator">*</span><span class="token punctuation">)</span><span class="token number">0x10000</span><span class="token punctuation">;</span>  <span class="token comment">// scratch space</span>

  <span class="token comment">// Read 1st page off disk</span>
  <span class="token function">readseg</span><span class="token punctuation">(</span><span class="token punctuation">(</span>uchar<span class="token operator">*</span><span class="token punctuation">)</span>elf<span class="token punctuation">,</span> <span class="token number">4096</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

  <span class="token comment">// Is this an ELF executable?</span>
  <span class="token keyword">if</span><span class="token punctuation">(</span>elf<span class="token operator">-></span>magic <span class="token operator">!=</span> ELF_MAGIC<span class="token punctuation">)</span>
    <span class="token keyword">return</span><span class="token punctuation">;</span>  <span class="token comment">// let bootasm.S handle error</span>

  <span class="token comment">// Load each program segment (ignores ph flags).</span>
  ph <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token keyword">struct</span> <span class="token class-name">proghdr</span><span class="token operator">*</span><span class="token punctuation">)</span><span class="token punctuation">(</span><span class="token punctuation">(</span>uchar<span class="token operator">*</span><span class="token punctuation">)</span>elf <span class="token operator">+</span> elf<span class="token operator">-></span>phoff<span class="token punctuation">)</span><span class="token punctuation">;</span>
  eph <span class="token operator">=</span> ph <span class="token operator">+</span> elf<span class="token operator">-></span>phnum<span class="token punctuation">;</span>
  <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token punctuation">;</span> ph <span class="token operator">&lt;</span> eph<span class="token punctuation">;</span> ph<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
    pa <span class="token operator">=</span> <span class="token punctuation">(</span>uchar<span class="token operator">*</span><span class="token punctuation">)</span>ph<span class="token operator">-></span>paddr<span class="token punctuation">;</span>
    <span class="token function">readseg</span><span class="token punctuation">(</span>pa<span class="token punctuation">,</span> ph<span class="token operator">-></span>filesz<span class="token punctuation">,</span> ph<span class="token operator">-></span>off<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">if</span><span class="token punctuation">(</span>ph<span class="token operator">-></span>memsz <span class="token operator">></span> ph<span class="token operator">-></span>filesz<span class="token punctuation">)</span>
      <span class="token function">stosb</span><span class="token punctuation">(</span>pa <span class="token operator">+</span> ph<span class="token operator">-></span>filesz<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> ph<span class="token operator">-></span>memsz <span class="token operator">-</span> ph<span class="token operator">-></span>filesz<span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span>

  <span class="token comment">// Call the entry point from the ELF header.</span>
  <span class="token comment">// Does not return!</span>
  entry <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token keyword">void</span><span class="token punctuation">(</span><span class="token operator">*</span><span class="token punctuation">)</span><span class="token punctuation">(</span><span class="token keyword">void</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">(</span>elf<span class="token operator">-></span>entry<span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token function">entry</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span></code></pre></div>
<p>始めに宣言されている構造体<code class="language-text">elfhdr</code>と<code class="language-text">proghdr</code>は、どちらも<code class="language-text">elf.h</code>で定義されています。</p>
<div class="gatsby-highlight" data-language="c"><pre class="language-c"><code class="language-c"><span class="token comment">// Format of an ELF executable file</span>

<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token macro-name">ELF_MAGIC</span> <span class="token expression"><span class="token number">0x464C457FU</span>  </span><span class="token comment">// "\x7FELF" in little endian</span></span>

<span class="token comment">// File header</span>
<span class="token keyword">struct</span> <span class="token class-name">elfhdr</span> <span class="token punctuation">{</span>
  uint magic<span class="token punctuation">;</span>  <span class="token comment">// must equal ELF_MAGIC</span>
  uchar elf<span class="token punctuation">[</span><span class="token number">12</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
  ushort type<span class="token punctuation">;</span>
  ushort machine<span class="token punctuation">;</span>
  uint version<span class="token punctuation">;</span>
  uint entry<span class="token punctuation">;</span>
  uint phoff<span class="token punctuation">;</span>
  uint shoff<span class="token punctuation">;</span>
  uint flags<span class="token punctuation">;</span>
  ushort ehsize<span class="token punctuation">;</span>
  ushort phentsize<span class="token punctuation">;</span>
  ushort phnum<span class="token punctuation">;</span>
  ushort shentsize<span class="token punctuation">;</span>
  ushort shnum<span class="token punctuation">;</span>
  ushort shstrndx<span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>

<span class="token comment">// Program section header</span>
<span class="token keyword">struct</span> <span class="token class-name">proghdr</span> <span class="token punctuation">{</span>
  uint type<span class="token punctuation">;</span>
  uint off<span class="token punctuation">;</span>
  uint vaddr<span class="token punctuation">;</span>
  uint paddr<span class="token punctuation">;</span>
  uint filesz<span class="token punctuation">;</span>
  uint memsz<span class="token punctuation">;</span>
  uint flags<span class="token punctuation">;</span>
  uint align<span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>

<span class="token comment">// Values for Proghdr type</span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token macro-name">ELF_PROG_LOAD</span>           <span class="token expression"><span class="token number">1</span></span></span>

<span class="token comment">// Flag bits for Proghdr flags</span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token macro-name">ELF_PROG_FLAG_EXEC</span>      <span class="token expression"><span class="token number">1</span></span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token macro-name">ELF_PROG_FLAG_WRITE</span>     <span class="token expression"><span class="token number">2</span></span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token macro-name">ELF_PROG_FLAG_READ</span>      <span class="token expression"><span class="token number">4</span></span></span></code></pre></div>
<p>この構造体の詳細については以下のページのままなので割愛します。</p>
<p>参考：<a href="https://en.wikipedia.org/wiki/Executable_and_Linkable_Format" target="_blank" rel="nofollow noopener noreferrer">Executable and Linkable Format - Wikipedia</a></p>
<p>次の行の<code class="language-text">void (*entry)(void);</code>では関数ポインタの宣言をしています。</p>
<p>最終的に、ロードしたELFヘッダのエントリポイントを取得して呼び出します。</p>
<h3 id="ディスクからセクタを読み取る" style="position:relative;"><a href="#%E3%83%87%E3%82%A3%E3%82%B9%E3%82%AF%E3%81%8B%E3%82%89%E3%82%BB%E3%82%AF%E3%82%BF%E3%82%92%E8%AA%AD%E3%81%BF%E5%8F%96%E3%82%8B" aria-label="ディスクからセクタを読み取る permalink" class="anchor before"><svg aria-hidden="true" focusable="false" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>ディスクからセクタを読み取る</h3>
<p>次は以下の箇所を見ていきます。</p>
<div class="gatsby-highlight" data-language="c"><pre class="language-c"><code class="language-c">elf <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token keyword">struct</span> <span class="token class-name">elfhdr</span><span class="token operator">*</span><span class="token punctuation">)</span><span class="token number">0x10000</span><span class="token punctuation">;</span>  <span class="token comment">// scratch space</span>

<span class="token comment">// Read 1st page off disk</span>
<span class="token function">readseg</span><span class="token punctuation">(</span><span class="token punctuation">(</span>uchar<span class="token operator">*</span><span class="token punctuation">)</span>elf<span class="token punctuation">,</span> <span class="token number">4096</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre></div>
<p><code class="language-text">elf = (struct elfhdr*)0x10000;</code>の行は何をしているのかいまいちわかっていなかったのですが、<code class="language-text">0x10000</code>番地からの領域を<code class="language-text">elfhdr</code>構造体としてキャストすることで、ポインタ変数<code class="language-text">elf</code>を通してこの領域にアクセスできるようにしています。</p>
<p>このポインタ変数<code class="language-text">elf</code>は、次の行で<code class="language-text">unsigned char</code>型のポインタにキャストされ、<code class="language-text">readseg</code>関数の第1引数として渡されています。</p>
<p>参考：<a href="https://vmm.dev/ja/lowlevel/xv6/xv6-1.md" target="_blank" rel="nofollow noopener noreferrer">xv6 のブートローダーを読む</a></p>
<p><code class="language-text">readseg((uchar*)elf, 4096, 0);</code>の行では、<code class="language-text">(uchar*)elf</code>のアドレスに4096バイトのデータをロードします。</p>
<p>ELFヘッダのサイズが52バイトであるにも関わらず4096バイトを読み込んでいる理由については下記が参考になりました。</p>
<p>参考：<a href="https://stackoverflow.com/questions/64795450/xv6-bootmain-loading-kernel-elf-header" target="_blank" rel="nofollow noopener noreferrer">x86 - XV6: bootmain - loading kernel ELF header - Stack Overflow</a></p>
<p>プログラム側からは、ELFヘッダとプログラムヘッダの組み合わせのサイズが呼び出し時点では不明なため、ELFヘッダとプログラムヘッダが4KBの範囲内に収まっていることを期待して、1ページ分のデータを読み込んでいる、という背景のようです。</p>
<p>※x86CPUの1ページ分のサイズは4069バイト(4KB)</p>
<p>参考：<a href="https://stackoverflow.com/questions/11543748/why-is-the-page-size-of-linux-x86-4-kb-how-is-that-calculated" target="_blank" rel="nofollow noopener noreferrer">Why is the page size of Linux (x86) 4 KB, how is that calculated? - Stack Overflow</a></p>
<p><code class="language-text">readseg</code>関数は以下のようなコードです。</p>
<p>内部の処理では、<code class="language-text">readsect</code>関数によって2番目のセクタ(セクタ1)から、4096バイト分のデータを1セクタずつディスクから読み込み、<code class="language-text">uchar* pa</code>の領域に書き込んでいきます。</p>
<div class="gatsby-highlight" data-language="c"><pre class="language-c"><code class="language-c"><span class="token comment">// Read 'count' bytes at 'offset' from kernel into physical address 'pa'.</span>
<span class="token comment">// Might copy more than asked.</span>
<span class="token keyword">void</span> <span class="token function">readseg</span><span class="token punctuation">(</span>uchar<span class="token operator">*</span> pa<span class="token punctuation">,</span> uint count<span class="token punctuation">,</span> uint offset<span class="token punctuation">)</span>
<span class="token punctuation">{</span>
  uchar<span class="token operator">*</span> epa<span class="token punctuation">;</span>
  epa <span class="token operator">=</span> pa <span class="token operator">+</span> count<span class="token punctuation">;</span>

  <span class="token comment">// Round down to sector boundary.</span>
  pa <span class="token operator">-=</span> offset <span class="token operator">%</span> SECTSIZE<span class="token punctuation">;</span>
  
  <span class="token comment">// Translate from bytes to sectors; kernel starts at sector 1.</span>
  offset <span class="token operator">=</span> <span class="token punctuation">(</span>offset <span class="token operator">/</span> SECTSIZE<span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">;</span>

  <span class="token comment">// If this is too slow, we could read lots of sectors at a time.</span>
  <span class="token comment">// We'd write more to memory than asked, but it doesn't matter --</span>
  <span class="token comment">// we load in increasing order.</span>
  <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token punctuation">;</span> pa <span class="token operator">&lt;</span> epa<span class="token punctuation">;</span> pa <span class="token operator">+=</span> SECTSIZE<span class="token punctuation">,</span> offset<span class="token operator">++</span><span class="token punctuation">)</span>
    <span class="token function">readsect</span><span class="token punctuation">(</span>pa<span class="token punctuation">,</span> offset<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span></code></pre></div>
<p>こちらが<code class="language-text">readsect</code>関数です。</p>
<div class="gatsby-highlight" data-language="c"><pre class="language-c"><code class="language-c"><span class="token comment">// Read a single sector at offset into dst.</span>
<span class="token keyword">void</span> <span class="token function">readsect</span><span class="token punctuation">(</span><span class="token keyword">void</span> <span class="token operator">*</span>dst<span class="token punctuation">,</span> uint offset<span class="token punctuation">)</span>
<span class="token punctuation">{</span>
  <span class="token comment">// Issue command.</span>
  <span class="token function">waitdisk</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token function">outb</span><span class="token punctuation">(</span><span class="token number">0x1F2</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>   <span class="token comment">// count = 1</span>
  <span class="token function">outb</span><span class="token punctuation">(</span><span class="token number">0x1F3</span><span class="token punctuation">,</span> offset<span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token function">outb</span><span class="token punctuation">(</span><span class="token number">0x1F4</span><span class="token punctuation">,</span> offset <span class="token operator">>></span> <span class="token number">8</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token function">outb</span><span class="token punctuation">(</span><span class="token number">0x1F5</span><span class="token punctuation">,</span> offset <span class="token operator">>></span> <span class="token number">16</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token function">outb</span><span class="token punctuation">(</span><span class="token number">0x1F6</span><span class="token punctuation">,</span> <span class="token punctuation">(</span>offset <span class="token operator">>></span> <span class="token number">24</span><span class="token punctuation">)</span> <span class="token operator">|</span> <span class="token number">0xE0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token function">outb</span><span class="token punctuation">(</span><span class="token number">0x1F7</span><span class="token punctuation">,</span> <span class="token number">0x20</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment">// cmd 0x20 - read sectors</span>

  <span class="token comment">// Read data.</span>
  <span class="token function">waitdisk</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token function">insl</span><span class="token punctuation">(</span><span class="token number">0x1F0</span><span class="token punctuation">,</span> dst<span class="token punctuation">,</span> SECTSIZE<span class="token operator">/</span><span class="token number">4</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span></code></pre></div>
<p>このようなディスクの呼び出しは<code class="language-text">Cylinder-head-sector(CHS)</code>と呼ばれる方法を使用しています。</p>
<p>昨今のOSでこのようなディスク読み出しを実装しているものは(おそらく)無いのでCHSの詳細については割愛します。</p>
<p>参考：<a href="https://en.wikipedia.org/wiki/Cylinder-head-sector" target="_blank" rel="nofollow noopener noreferrer">Cylinder-head-sector - Wikipedia</a></p>
<p>参考：<a href="https://stackoverflow.com/questions/61028931/xv6-boot-loader-reading-sectors-off-disk-using-chs" target="_blank" rel="nofollow noopener noreferrer">c - xv6 boot loader: Reading sectors off disk using CHS - Stack Overflow</a></p>
<p>ここでなぜ<code class="language-text">offset = (offset / SECTSIZE) + 1;</code>の行で、2番目のセクタ(セクタ1)からデータを読み込んでいるのかというと、Makefileの項で確認した通り、カーネルプログラムはイメージの先頭512バイトの位置に配置されているためです。</p>
<p><span
      class="gatsby-resp-image-wrapper"
      style="position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 500px; "
    >
      <a
    class="gatsby-resp-image-link"
    href="/static/0ee723f0df4390ef428db10febeb6cfd/0b533/image-8-16455921223972.png"
    style="display: block"
    target="_blank"
    rel="noopener"
  >
    <span
    class="gatsby-resp-image-background-image"
    style="padding-bottom: 75%; position: relative; bottom: 0; left: 0; background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAPCAYAAADkmO9VAAAACXBIWXMAARlAAAEZQAGA43XUAAABiElEQVQ4y8WU6XaCMBBGff8Hah+gdtGiApGqaCsgFgmgHDZ3viZxpaL1X3POPWFmwiXDVsF+bLdbRFFUII5jJEki4Me/65vNRpyb5/lBg0oQ+IjY4vVqhW9KQcwRNMsWEMNCo9dHUx+ADM1Tnq2xnAm2ZcLlcon1es12uIE9cVHTh3gfGJAGJl47AzxUa3h8qeNZ0yF9mixviDXDsYOcdXUhxNlwPAeNLxmyQRiqmMlIEygmQWufaw5lGI5ZLuTBIeGHFF0qo+8T6B5HFce7WN3nCHqeAtszWcsn4YGC0Ju5+JjI6LkEXVdlEKijBhRLOsacjsuEtCgstHwhpDshn+t6FW/dp13MZL0rwuMOC8LQFYt1ry1knL6vCQ4xr3WpgrFnYZ4tQKmLsW0jCKbgD7ggpNMJa1GCNm6hfaS5ZxfzGrElWK7BdpjfbjlOYqTzBOkiZSTlsHrG6mE4E6/bzZazbI57B/96zoWlO8yyrHC1a4hu+Nf1L8J7x13CNE3FveHzX1z72/wARuV7fAc3xmkAAAAASUVORK5CYII='); background-size: cover; display: block;"
  ></span>
  <picture>
          <source
              srcset="/static/0ee723f0df4390ef428db10febeb6cfd/8ac56/image-8-16455921223972.webp 240w,
/static/0ee723f0df4390ef428db10febeb6cfd/d3be9/image-8-16455921223972.webp 480w,
/static/0ee723f0df4390ef428db10febeb6cfd/b0a15/image-8-16455921223972.webp 500w"
              sizes="(max-width: 500px) 100vw, 500px"
              type="image/webp"
            />
          <source
            srcset="/static/0ee723f0df4390ef428db10febeb6cfd/8ff5a/image-8-16455921223972.png 240w,
/static/0ee723f0df4390ef428db10febeb6cfd/e85cb/image-8-16455921223972.png 480w,
/static/0ee723f0df4390ef428db10febeb6cfd/0b533/image-8-16455921223972.png 500w"
            sizes="(max-width: 500px) 100vw, 500px"
            type="image/png"
          />
          <img
            class="gatsby-resp-image-image"
            src="/static/0ee723f0df4390ef428db10febeb6cfd/0b533/image-8-16455921223972.png"
            alt="img"
            title="img"
            loading="lazy"
            style="width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;"
          />
        </picture>
  </a>
    </span></p>
<p>xv6OSでは、<code class="language-text">\#define SECTSIZE  512</code>とある通り、1セクタ分のサイズが512バイトと定義されています。</p>
<p>そのため、2セクタ目の先頭にはカーネルの先頭バイトが存在していることが期待されます。</p>
<h3 id="読み込んだカーネルの確認" style="position:relative;"><a href="#%E8%AA%AD%E3%81%BF%E8%BE%BC%E3%82%93%E3%81%A0%E3%82%AB%E3%83%BC%E3%83%8D%E3%83%AB%E3%81%AE%E7%A2%BA%E8%AA%8D" aria-label="読み込んだカーネルの確認 permalink" class="anchor before"><svg aria-hidden="true" focusable="false" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>読み込んだカーネルの確認</h3>
<p>次の処理では、カーネルが正常に読み込まれているか確認するため、マジックナンバを参照しています。</p>
<div class="gatsby-highlight" data-language="c"><pre class="language-c"><code class="language-c"><span class="token comment">// Is this an ELF executable?</span>
<span class="token keyword">if</span><span class="token punctuation">(</span>elf<span class="token operator">-></span>magic <span class="token operator">!=</span> ELF_MAGIC<span class="token punctuation">)</span>
	<span class="token keyword">return</span><span class="token punctuation">;</span>  <span class="token comment">// let bootasm.S handle error</span></code></pre></div>
<h3 id="プログラムヘッダの読み込み" style="position:relative;"><a href="#%E3%83%97%E3%83%AD%E3%82%B0%E3%83%A9%E3%83%A0%E3%83%98%E3%83%83%E3%83%80%E3%81%AE%E8%AA%AD%E3%81%BF%E8%BE%BC%E3%81%BF" aria-label="プログラムヘッダの読み込み permalink" class="anchor before"><svg aria-hidden="true" focusable="false" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>プログラムヘッダの読み込み</h3>
<p>続いて、プログラムヘッダを読み込みます。</p>
<p>基本的にはカーネルを読み込んだ際とほとんど同じ挙動のようです。</p>
<div class="gatsby-highlight" data-language="c"><pre class="language-c"><code class="language-c"><span class="token comment">// Load each program segment (ignores ph flags).</span>
ph <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token keyword">struct</span> <span class="token class-name">proghdr</span><span class="token operator">*</span><span class="token punctuation">)</span><span class="token punctuation">(</span><span class="token punctuation">(</span>uchar<span class="token operator">*</span><span class="token punctuation">)</span>elf <span class="token operator">+</span> elf<span class="token operator">-></span>phoff<span class="token punctuation">)</span><span class="token punctuation">;</span>
eph <span class="token operator">=</span> ph <span class="token operator">+</span> elf<span class="token operator">-></span>phnum<span class="token punctuation">;</span>
<span class="token keyword">for</span><span class="token punctuation">(</span><span class="token punctuation">;</span> ph <span class="token operator">&lt;</span> eph<span class="token punctuation">;</span> ph<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
  pa <span class="token operator">=</span> <span class="token punctuation">(</span>uchar<span class="token operator">*</span><span class="token punctuation">)</span>ph<span class="token operator">-></span>paddr<span class="token punctuation">;</span>
  <span class="token function">readseg</span><span class="token punctuation">(</span>pa<span class="token punctuation">,</span> ph<span class="token operator">-></span>filesz<span class="token punctuation">,</span> ph<span class="token operator">-></span>off<span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token keyword">if</span><span class="token punctuation">(</span>ph<span class="token operator">-></span>memsz <span class="token operator">></span> ph<span class="token operator">-></span>filesz<span class="token punctuation">)</span>
    <span class="token function">stosb</span><span class="token punctuation">(</span>pa <span class="token operator">+</span> ph<span class="token operator">-></span>filesz<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> ph<span class="token operator">-></span>memsz <span class="token operator">-</span> ph<span class="token operator">-></span>filesz<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span></code></pre></div>
<p>まず、<code class="language-text">(uchar*)elf + elf->phoff</code>のアドレスを<code class="language-text">proghdr</code>構造体としてキャストします。</p>
<p><code class="language-text">(uchar*)elf + elf->phoff</code>はプログラムヘッダの開始オフセットです。</p>
<p>先ほど4096バイト分のデータを読み込んだことで、ELFヘッダとともにプログラムヘッダもすべて読み込まれていることが期待されているため、<code class="language-text">(uchar*)elf + elf->phoff</code>の位置にはすでにプログラムヘッダの情報が格納されています。</p>
<p>ここから、各プログラムセグメントのデータをロードします。</p>
<p>この処理によって、実際に実行されるプログラムがロードされます。</p>
<p>なお、<code class="language-text">stosb</code>は<code class="language-text">x86.h</code>で定義されており、<code class="language-text">ph->memsz</code>が<code class="language-text">ph->filesz</code>よりも大きい場合に0埋めするために利用されています。</p>
<div class="gatsby-highlight" data-language="c"><pre class="language-c"><code class="language-c"><span class="token keyword">static</span> <span class="token keyword">inline</span> <span class="token keyword">void</span>
<span class="token function">stosb</span><span class="token punctuation">(</span><span class="token keyword">void</span> <span class="token operator">*</span>addr<span class="token punctuation">,</span> <span class="token keyword">int</span> data<span class="token punctuation">,</span> <span class="token keyword">int</span> cnt<span class="token punctuation">)</span>
<span class="token punctuation">{</span>
  <span class="token keyword">asm</span> <span class="token keyword">volatile</span><span class="token punctuation">(</span><span class="token string">"cld; rep stosb"</span> <span class="token operator">:</span>
               <span class="token string">"=D"</span> <span class="token punctuation">(</span>addr<span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token string">"=c"</span> <span class="token punctuation">(</span>cnt<span class="token punctuation">)</span> <span class="token operator">:</span>
               <span class="token string">"0"</span> <span class="token punctuation">(</span>addr<span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token string">"1"</span> <span class="token punctuation">(</span>cnt<span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token string">"a"</span> <span class="token punctuation">(</span>data<span class="token punctuation">)</span> <span class="token operator">:</span>
               <span class="token string">"memory"</span><span class="token punctuation">,</span> <span class="token string">"cc"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span></code></pre></div>
<p>参考：<a href="https://stackoverflow.com/questions/27958743/difference-between-p-filesz-and-p-memsz-of-elf32-phdr/31011428#31011428" target="_blank" rel="nofollow noopener noreferrer">elf - Difference between p<em>filesz and p</em>memsz of Elf32_Phdr - Stack Overflow</a></p>
<p>これでディスクからカーネルプログラムを読み込むことができたので、以降の処理はカーネルに任せることとなります。</p>
<div class="gatsby-highlight" data-language="c"><pre class="language-c"><code class="language-c"><span class="token comment">// Call the entry point from the ELF header.</span>
<span class="token comment">// Does not return!</span>
entry <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token keyword">void</span><span class="token punctuation">(</span><span class="token operator">*</span><span class="token punctuation">)</span><span class="token punctuation">(</span><span class="token keyword">void</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">(</span>elf<span class="token operator">-></span>entry<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token function">entry</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre></div>
<h2 id="まとめ" style="position:relative;"><a href="#%E3%81%BE%E3%81%A8%E3%82%81" aria-label="まとめ permalink" class="anchor before"><svg aria-hidden="true" focusable="false" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>まとめ</h2>
<p>結構時間がかかりましたがxv6 UNIXのブートストラップについて深掘りしつつ読み込みました。</p>
<p>次回からようやく本題(カーネルのソースコードを読む)に入れそうです。</p>
<h2 id="参考書籍" style="position:relative;"><a href="#%E5%8F%82%E8%80%83%E6%9B%B8%E7%B1%8D" aria-label="参考書籍 permalink" class="anchor before"><svg aria-hidden="true" focusable="false" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>参考書籍</h2>
<ul>
<li><a href="https://amzn.to/3qZSCY7" target="_blank" rel="nofollow noopener noreferrer">30日でできる! OS自作入門</a></li>
<li><a href="https://amzn.to/3qXYsZX" target="_blank" rel="nofollow noopener noreferrer">ゼロからのOS自作入門</a></li>
<li><a href="https://amzn.to/3q8TU3K" target="_blank" rel="nofollow noopener noreferrer">はじめてのOSコードリーディング ~UNIX V6で学ぶカーネルのしくみ</a></li>
<li><a href="https://amzn.to/3I6fkVt" target="_blank" rel="nofollow noopener noreferrer">詳解 Linuxカーネル</a></li>
<li><a href="https://amzn.to/3JRUdI2" target="_blank" rel="nofollow noopener noreferrer">作って理解するOS x86系コンピュータを動かす理論と実装</a></li>
</ul></div></div></div><div class="Post-module--post__footer--3WzWU"><div><p class="Meta-module--meta__date--29eD7">Published <!-- -->Jan 10, 2022</p></div><div class="Tags-module--tags--1L_ct"><ul class="Tags-module--tags__list--91FqN"><li class="Tags-module--tags__list-item--1M30P"><a class="Tags-module--tags__list-item-link--3SL_8" href="/tag/unix/">Unix</a></li><li class="Tags-module--tags__list-item--1M30P"><a class="Tags-module--tags__list-item-link--3SL_8" href="/tag/xv-6/">xv6</a></li><li class="Tags-module--tags__list-item--1M30P"><a class="Tags-module--tags__list-item-link--3SL_8" href="/tag/kernel/">Kernel</a></li><li class="Tags-module--tags__list-item--1M30P"><a class="Tags-module--tags__list-item-link--3SL_8" href="/tag/os/">OS</a></li></ul></div><div class="Author-module--author--2Yefr"><p>リバースエンジニアになりたいCTF Player(Team: 0nePadding)。WinDbgとYARAが好き。OSCP / CISSP / AtCoder 緑 Microsoft Japanに所属してます。発言はすべて個人の見解。<a class="Author-module--author__bio-twitter--n-O9n" href="https://www.twitter.com/kash1064" rel="noopener noreferrer" target="_blank"><strong>かしわば</strong> on Twitter</a></p></div></div><div class="Post-module--post__comments--25y6I"></div></div></div></div><div id="gatsby-announcer" style="position:absolute;top:0;width:1px;height:1px;padding:0;overflow:hidden;clip:rect(0, 0, 0, 0);white-space:nowrap;border:0" aria-live="assertive" aria-atomic="true"></div></div><script id="gatsby-script-loader">/*<![CDATA[*/window.pagePath="/unix-xv6-001-bootstrap";/*]]>*/</script><script id="gatsby-chunk-mapping">/*<![CDATA[*/window.___chunkMapping={"polyfill":["/polyfill-299cfcade846097f4d4b.js"],"app":["/app-d190fa369444a992009d.js"],"component---cache-caches-gatsby-plugin-offline-app-shell-js":["/component---cache-caches-gatsby-plugin-offline-app-shell-js-fd4fb51a6fac1c18bdde.js"],"component---src-templates-categories-list-template-js":["/component---src-templates-categories-list-template-js-2181ec47d28e5c35d3e9.js"],"component---src-templates-category-template-js":["/component---src-templates-category-template-js-76f2006942127b3c7274.js"],"component---src-templates-index-template-js":["/component---src-templates-index-template-js-70ba56c0f46525baa629.js"],"component---src-templates-not-found-template-js":["/component---src-templates-not-found-template-js-d19905e5c8fc953958f1.js"],"component---src-templates-page-template-js":["/component---src-templates-page-template-js-6ba68ef37e264f701345.js"],"component---src-templates-post-template-js":["/component---src-templates-post-template-js-381c1b847824134fa4bd.js"],"component---src-templates-tag-template-js":["/component---src-templates-tag-template-js-0faa242d92f89b71e668.js"],"component---src-templates-tags-list-template-js":["/component---src-templates-tags-list-template-js-2d7007993fc2bf0f9caf.js"]};/*]]>*/</script><script src="/polyfill-299cfcade846097f4d4b.js" nomodule=""></script><script src="/component---src-templates-post-template-js-381c1b847824134fa4bd.js" async=""></script><script src="/cd95ea5cbd2c605f26db819f07999610c9ff4310-c2f05dc74373de400085.js" async=""></script><script src="/styles-407fe62976dc5310c43e.js" async=""></script><script src="/app-d190fa369444a992009d.js" async=""></script><script src="/dc6a8720040df98778fe970bf6c000a41750d3ae-7f15a6c248118ef4fef1.js" async=""></script><script src="/532a2f07-92db97c0addf07d5cb73.js" async=""></script><script src="/framework-3761df4ab6ee9f056936.js" async=""></script><script src="/webpack-runtime-a3c0f166cb4b802ff58f.js" async=""></script></body></html>